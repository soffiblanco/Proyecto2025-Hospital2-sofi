\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

% Paquetes para diagramas TikZ
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{shapes,arrows,positioning,fit,backgrounds,calc,decorations.pathreplacing}
\pgfplotsset{compat=1.18}

% Configuración de página
\geometry{margin=2.5cm}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{PROYECTO2025-HOSPITAL2-SOFI}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Configuración de colores para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configuración de listings
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Configuración de títulos
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

\begin{document}

% Portada
\begin{titlepage}
\centering
\vspace*{2cm}

{\Huge\bfseries DOCUMENTACIÓN COMPLETA}\\[0.5cm]
{\Huge\bfseries PROYECTO2025-HOSPITAL2-SOFI}\\[2cm]

{\Large Sistema Integral de Gestión Hospitalaria}\\[1cm]

\vspace{2cm}

\begin{tabular}{ll}
\textbf{Versión:} & 1.0.0 \\
\textbf{Fecha:} & \today \\
\textbf{Tecnologías:} & Quarkus, Vue.js 3, SQLite \\
\textbf{Arquitectura:} & Microservicios, CI/CD \\
\end{tabular}

\vfill

{\large Sistema desarrollado con tecnologías modernas para la gestión integral de hospitales}

\end{titlepage}

\tableofcontents
\newpage

\section{Introducción}

El \textbf{PROYECTO2025-HOSPITAL2-SOFI} es un sistema integral de gestión hospitalaria desarrollado con tecnologías modernas que incluye un backend basado en Quarkus (Java), un frontend desarrollado en Vue.js 3, y un pipeline de CI/CD automatizado con Jenkins. El sistema está diseñado para manejar múltiples aspectos de la gestión hospitalaria incluyendo usuarios, pacientes, doctores, empleados, citas médicas, historias clínicas, servicios médicos y reportes.

\subsection{Características Principales}
\begin{itemize}
    \item \textbf{Arquitectura de Microservicios}: Backend modular con Quarkus
    \item \textbf{Frontend Moderno}: Vue.js 3 con TypeScript y Tailwind CSS
    \item \textbf{Base de Datos}: SQLite con soporte multi-entorno (dev, uat, prod)
    \item \textbf{Autenticación y Autorización}: Sistema de roles basado en JWT
    \item \textbf{CI/CD Automatizado}: Pipeline Jenkins con análisis de calidad
    \item \textbf{Contenedorización}: Docker para despliegue consistente
    \item \textbf{Multi-entorno}: Soporte para desarrollo, UAT y producción
\end{itemize}

\section{Arquitectura del Sistema}

\subsection{Arquitectura General}

El sistema sigue una arquitectura de \textbf{3 capas} con separación clara de responsabilidades:

\begin{enumerate}
    \item \textbf{Capa de Presentación}: Vue.js 3, Tailwind CSS, Router, Pinia Store
    \item \textbf{Capa de Lógica de Negocio}: Quarkus Backend, REST APIs, Service Layer
    \item \textbf{Capa de Datos}: SQLite Database, Hibernate ORM, JPA Entities
\end{enumerate}

\subsection{Diagrama de Arquitectura General}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    box/.style={rectangle, draw, fill=blue!20, text width=3cm, text centered, minimum height=1cm},
    layer/.style={rectangle, draw, fill=gray!20, text width=12cm, text centered, minimum height=1.5cm},
    arrow/.style={->, thick}
]

% Capa de Presentación
\node[layer, fill=green!20] (presentation) at (0,6) {CAPA DE PRESENTACIÓN};
\node[box] (vue) at (-3,5) {Vue.js 3\\Frontend};
\node[box] (tailwind) at (0,5) {Tailwind CSS\\Styling};
\node[box] (router) at (3,5) {Router\\Guards};

% Capa de Aplicación
\node[layer, fill=yellow!20] (application) at (0,3.5) {CAPA DE LÓGICA DE NEGOCIO};
\node[box] (quarkus) at (-3,2.5) {Quarkus\\Backend};
\node[box] (rest) at (0,2.5) {REST APIs\\Resources};
\node[box] (service) at (3,2.5) {Service\\Layer};

% Capa de Datos
\node[layer, fill=red!20] (data) at (0,1) {CAPA DE DATOS};
\node[box] (sqlite) at (-3,0) {SQLite\\Database};
\node[box] (hibernate) at (0,0) {Hibernate ORM\\JPA Entities};
\node[box] (panache) at (3,0) {Panache\\Repos};

% Flechas
\draw[arrow] (vue) -- (quarkus);
\draw[arrow] (tailwind) -- (rest);
\draw[arrow] (router) -- (service);
\draw[arrow] (quarkus) -- (sqlite);
\draw[arrow] (rest) -- (hibernate);
\draw[arrow] (service) -- (panache);

\end{tikzpicture}
\caption{Arquitectura de 3 Capas del Sistema}
\end{figure}

\subsection{Patrones Arquitectónicos Implementados}

\begin{enumerate}
    \item \textbf{MVC (Model-View-Controller)}
    \begin{itemize}
        \item \textbf{Model}: Entidades JPA en el backend
        \item \textbf{View}: Componentes Vue.js en el frontend
        \item \textbf{Controller}: Resources REST en Quarkus
    \end{itemize}
    
    \item \textbf{Repository Pattern}
    \begin{itemize}
        \item Implementado con Panache para acceso a datos
        \item Separación entre lógica de negocio y acceso a datos
    \end{itemize}
    
    \item \textbf{Service Layer Pattern}
    \begin{itemize}
        \item Servicios de negocio que encapsulan la lógica compleja
        \item Separación entre controladores y repositorios
    \end{itemize}
    
    \item \textbf{Dependency Injection}
    \begin{itemize}
        \item Quarkus CDI para inyección de dependencias
        \item Vue.js Composition API para gestión de estado
    \end{itemize}
\end{enumerate}

\section{Componentes del Sistema}

\subsection{Backend (Quarkus)}

\subsubsection{Estructura de Paquetes}
\begin{lstlisting}[language=bash]
com.unis/
├── controller/          # Controladores REST principales
├── resource/            # Recursos REST específicos
├── service/            # Lógica de negocio
├── repository/          # Acceso a datos
├── model/              # Entidades JPA
├── dto/                # Objetos de transferencia de datos
└── config/             # Configuraciones
\end{lstlisting}

\subsubsection{Tecnologías Backend}
\begin{itemize}
    \item \textbf{Framework}: Quarkus 3.8.6
    \item \textbf{Java}: OpenJDK 17+
    \item \textbf{ORM}: Hibernate ORM con Panache
    \item \textbf{Base de Datos}: SQLite 3.45.3.0
    \item \textbf{API}: RESTEasy Reactive
    \item \textbf{Testing}: JUnit 5, Mockito, RestAssured
    \item \textbf{Documentación}: Apache POI para reportes Excel
\end{itemize}

\subsection{Frontend (Vue.js 3)}

\subsubsection{Estructura de Componentes}
\begin{lstlisting}[language=bash]
src/
├── components/         # Componentes reutilizables
├── views/              # Vistas principales
│   ├── admin/          # Vistas administrativas
│   ├── doctores/       # Vistas para doctores
│   └── vistasSimuladas/ # Vistas simuladas
├── services/           # Servicios de API
├── stores/             # Gestión de estado (Pinia)
├── router/             # Configuración de rutas
└── assets/             # Recursos estáticos
\end{lstlisting}

\subsubsection{Tecnologías Frontend}
\begin{itemize}
    \item \textbf{Framework}: Vue.js 3.5.13
    \item \textbf{Lenguaje}: TypeScript 5.7.3
    \item \textbf{Styling}: Tailwind CSS 4.0.6
    \item \textbf{Estado}: Pinia 2.3.1
    \item \textbf{HTTP Client}: Axios 1.7.9
    \item \textbf{Testing}: Vitest, Playwright
    \item \textbf{Build Tool}: Vite 6.0.11
\end{itemize}

\section{Base de Datos}

\subsection{Modelo de Datos}

El sistema utiliza SQLite como base de datos principal con las siguientes entidades principales:

\subsubsection{Entidades Core}
\begin{itemize}
    \item \textbf{Usuario}: Gestión de cuentas de usuario
    \item \textbf{Rol}: Definición de roles del sistema
    \item \textbf{Hospital}: Información de hospitales
    \item \textbf{UserAcc}: Cuentas de usuario con autenticación
\end{itemize}

\subsubsection{Entidades de Negocio}
\begin{itemize}
    \item \textbf{Paciente}: Información de pacientes
    \item \textbf{Doctor}: Información de doctores
    \item \textbf{Empleado}: Información de empleados
    \item \textbf{Cita}: Citas médicas
    \item \textbf{Historia}: Historias clínicas
    \item \textbf{Servicio}: Servicios médicos
    \item \textbf{Medicamento}: Medicamentos y recetas
    \item \textbf{FichaTecnica}: Fichas técnicas médicas
\end{itemize}

\subsubsection{Entidades de Soporte}
\begin{itemize}
    \item \textbf{UsuarioInter}: Usuarios de interconexión
    \item \textbf{SolicitudHospital}: Solicitudes de hospitales
    \item \textbf{Receta}: Recetas médicas
    \item \textbf{RecetaMedicamento}: Relación receta-medicamento
\end{itemize}

\subsection{Diagrama de Base de Datos (ERD)}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    entity/.style={rectangle, draw, fill=blue!20, text width=2.5cm, text centered, minimum height=1cm},
    relationship/.style={diamond, draw, fill=green!20, text width=1cm, text centered, minimum height=0.8cm},
    attribute/.style={ellipse, draw, fill=yellow!20, text width=1.5cm, text centered, minimum height=0.6cm}
]

% Entidades principales
\node[entity] (usuario) at (0,8) {USUARIO};
\node[entity] (rol) at (-4,6) {ROL};
\node[entity] (hospital) at (4,6) {HOSPITAL};
\node[entity] (paciente) at (-2,4) {PACIENTE};
\node[entity] (doctor) at (2,4) {DOCTOR};
\node[entity] (empleado) at (0,2) {EMPLEADO};
\node[entity] (cita) at (-2,0) {CITA};
\node[entity] (historia) at (2,0) {HISTORIA};
\node[entity] (servicio) at (-4,-2) {SERVICIO};
\node[entity] (medicamento) at (0,-2) {MEDICAMENTO};
\node[entity] (receta) at (4,-2) {RECETA};

% Relaciones
\node[relationship] (r1) at (-2,7) {tiene};
\node[relationship] (r2) at (2,7) {pertenece};
\node[relationship] (r3) at (-1,6) {es};
\node[relationship] (r4) at (1,6) {es};
\node[relationship] (r5) at (0,3) {es};
\node[relationship] (r6) at (-1,2) {agenda};
\node[relationship] (r7) at (1,2) {crea};
\node[relationship] (r8) at (-3,-1) {contiene};
\node[relationship] (r9) at (2,-1) {incluye};

% Conexiones
\draw (usuario) -- (r1) -- (rol);
\draw (usuario) -- (r2) -- (hospital);
\draw (usuario) -- (r3) -- (paciente);
\draw (usuario) -- (r4) -- (doctor);
\draw (usuario) -- (r5) -- (empleado);
\draw (paciente) -- (r6) -- (cita);
\draw (doctor) -- (r6) -- (cita);
\draw (doctor) -- (r7) -- (historia);
\draw (cita) -- (r8) -- (receta);
\draw (receta) -- (r9) -- (medicamento);

% Atributos principales
\node[attribute] (id_usuario) at (-2,9) {ID\_USUARIO};
\node[attribute] (nombre) at (2,9) {NOMBRE};
\node[attribute] (correo) at (0,10) {CORREO};

\draw (id_usuario) -- (usuario);
\draw (nombre) -- (usuario);
\draw (correo) -- (usuario);

\end{tikzpicture}
\caption{Diagrama de Entidad-Relación (ERD) del Sistema}
\end{figure}

\subsection{Configuración Multi-entorno}

\begin{lstlisting}[language=properties]
# Desarrollo
%dev.quarkus.datasource.jdbc.url=jdbc:sqlite:./data/dev.db
%dev.quarkus.hibernate-orm.database.generation=update

# UAT
%uat.quarkus.datasource.jdbc.url=jdbc:sqlite:./data/uat.db
%uat.quarkus.hibernate-orm.database.generation=validate

# Producción
%prod.quarkus.datasource.jdbc.url=jdbc:sqlite:./data/prod.db
%prod.quarkus.hibernate-orm.database.generation=validate
\end{lstlisting}

\section{API REST}

\subsection{Endpoints Principales}

\subsubsection{Autenticación y Usuarios}
\begin{lstlisting}[language=bash]
POST /usuarios/login              # Inicio de sesión
POST /usuarios/registro           # Registro de usuarios
GET  /usuarios/inactivos         # Usuarios inactivos
GET  /usuarios/roles             # Lista de roles
PUT  /usuarios/{id}/activar      # Activar usuario
\end{lstlisting}

\subsubsection{Gestión de Pacientes}
\begin{lstlisting}[language=bash]
GET    /paciente                 # Listar pacientes
GET    /paciente/{id}            # Obtener paciente
POST   /paciente                 # Crear paciente
PUT    /paciente/{id}            # Actualizar paciente
DELETE /paciente/{id}            # Eliminar paciente
\end{lstlisting}

\subsubsection{Gestión de Doctores}
\begin{lstlisting}[language=bash]
GET    /doctor                   # Listar doctores
GET    /doctor/{id}              # Obtener doctor
POST   /doctor                   # Crear doctor
PUT    /doctor/{id}              # Actualizar doctor
DELETE /doctor/{id}              # Eliminar doctor
\end{lstlisting}

\subsubsection{Gestión de Empleados}
\begin{lstlisting}[language=bash]
GET    /empleado                 # Listar empleados
GET    /empleado/{id}            # Obtener empleado
POST   /empleado                 # Crear empleado
PUT    /empleado/{id}            # Actualizar empleado
DELETE /empleado/{id}            # Eliminar empleado
\end{lstlisting}

\subsubsection{Citas Médicas}
\begin{lstlisting}[language=bash]
GET    /citas                    # Listar citas
GET    /citas/{id}               # Obtener cita
POST   /citas                    # Crear cita
PUT    /citas/{id}              # Actualizar cita
DELETE /citas/{id}              # Eliminar cita
\end{lstlisting}

\subsubsection{Servicios Médicos}
\begin{lstlisting}[language=bash]
GET    /api/servicios            # Listar servicios
GET    /api/servicios/{id}/subservicios # Subservicios
POST   /api/servicios            # Crear servicio
PUT    /api/servicios/{id}       # Actualizar servicio
DELETE /api/servicios/{id}       # Eliminar servicio
\end{lstlisting}

\subsection{Características de la API}

\begin{itemize}
    \item \textbf{Formato}: JSON
    \item \textbf{Autenticación}: JWT Bearer Token
    \item \textbf{CORS}: Configurado para desarrollo local
    \item \textbf{Validación}: Validación de entrada en todos los endpoints
    \item \textbf{Manejo de Errores}: Respuestas HTTP estándar con mensajes descriptivos
\end{itemize}

\section{Frontend}

\subsection{Arquitectura de Componentes}

\subsubsection{Estructura de Rutas}
\begin{lstlisting}[language=typescript]
// Rutas públicas
/                    # Página principal
/login              # Inicio de sesión
/signup             # Registro
/faq                # Preguntas frecuentes
/servicios-medicos  # Servicios médicos
/historia           # Historia del hospital
/doctores           # Catálogo de doctores

// Rutas por rol
/admin-portal       # Portal administrativo (Admin)
/my-account-*       # Cuentas personales por rol
/recetas           # Recetas médicas (Doctor)
/consultar-historial # Historial (Paciente)
\end{lstlisting}

\subsubsection{Sistema de Roles}
\begin{lstlisting}[language=typescript]
const ROLES = {
  Admin:    1,
  Doctor:   2,
  Empleado: 3,
  Paciente: 4
} as const;
\end{lstlisting}

\subsubsection{Guards de Navegación}
\begin{itemize}
    \item \textbf{requireAuth}: Verifica autenticación
    \item \textbf{requireRole}: Verifica roles específicos
    \item \textbf{Redirección automática}: Basada en roles de usuario
\end{itemize}

\subsection{Servicios Frontend}

\subsubsection{Servicios de API}
\begin{itemize}
    \item \textbf{authService.js}: Autenticación y autorización
    \item \textbf{pacienteService.js}: Gestión de pacientes
    \item \textbf{doctorService.js}: Gestión de doctores
    \item \textbf{citaService.js}: Gestión de citas
    \item \textbf{historiaService.js}: Historias clínicas
    \item \textbf{servicioService.js}: Servicios médicos
\end{itemize}

\subsubsection{Gestión de Estado}
\begin{itemize}
    \item \textbf{Pinia Store}: Estado global de la aplicación
    \item \textbf{authStore.ts}: Estado de autenticación
    \item \textbf{LocalStorage}: Persistencia de sesión
\end{itemize}

\section{Pipeline de CI/CD}

\subsection{Diagrama de Pipeline CI/CD}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    stage/.style={rectangle, draw, fill=blue!20, text width=2.5cm, text centered, minimum height=1cm},
    decision/.style={diamond, draw, fill=red!20, text width=2cm, text centered, minimum height=1cm},
    arrow/.style={->, thick},
    success/.style={fill=green!20},
    failure/.style={fill=red!20}
]

% Etapas del pipeline
\node[stage] (checkout) at (0,8) {Checkout\\Code};
\node[stage] (build) at (0,6) {Build \&\\Tests};
\node[stage] (sonar) at (0,4) {SonarQube\\Analysis};
\node[decision] (quality) at (0,2) {Quality\\Gate};
\node[stage] (docker) at (0,0) {Docker\\Build};
\node[stage] (deploy) at (0,-2) {Deploy\\Multi-env};

% Etapas paralelas
\node[stage, success] (unit) at (-3,6) {Unit\\Tests};
\node[stage, success] (integration) at (3,6) {Integration\\Tests};

% Ambientes de despliegue
\node[stage, fill=green!20] (dev) at (-3,-2) {Dev\\:3001};
\node[stage, fill=yellow!20] (uat) at (0,-4) {UAT\\:3002};
\node[stage, fill=red!20] (prod) at (3,-2) {Prod\\:3003};

% Flechas principales
\draw[arrow] (checkout) -- (build);
\draw[arrow] (build) -- (sonar);
\draw[arrow] (sonar) -- (quality);
\draw[arrow] (quality) -- node[right] {Pass} (docker);
\draw[arrow] (quality) -- node[left] {Fail} ++(-2,0) -- ++(0,-3) -- (checkout);
\draw[arrow] (docker) -- (deploy);

% Flechas paralelas
\draw[arrow] (build) -- (unit);
\draw[arrow] (build) -- (integration);
\draw[arrow] (unit) -- (sonar);
\draw[arrow] (integration) -- (sonar);

% Flechas de despliegue
\draw[arrow] (deploy) -- (dev);
\draw[arrow] (deploy) -- (uat);
\draw[arrow] (deploy) -- (prod);

\end{tikzpicture}
\caption{Pipeline de CI/CD con Análisis de Calidad}
\end{figure}

\subsection{Configuración Jenkins}

El pipeline está configurado en \texttt{Dockerfile.jenkins} con las siguientes etapas:

\subsubsection{Etapa 1: Checkout}
\begin{lstlisting}[language=groovy]
stage('Checkout') {
  steps { checkout scm }
}
\end{lstlisting}

\subsubsection{Etapa 2: Build \& Tests}
\begin{lstlisting}[language=groovy]
stage('Build & Tests (Maven)') {
  steps {
    sh 'mvn -f backend/pom.xml -B -DskipTests=false clean verify'
  }
}
\end{lstlisting}

\subsubsection{Etapa 3: Análisis de Calidad}
\begin{lstlisting}[language=groovy]
stage('SonarQube Analysis') {
  steps {
    withSonarQubeEnv("${SONARQUBE_ENV}") {
      sh 'mvn -f backend/pom.xml -B sonar:sonar'
    }
  }
}
\end{lstlisting}

\subsubsection{Etapa 4: Quality Gate}
\begin{lstlisting}[language=groovy]
stage('Quality Gate') {
  steps {
    timeout(time: 5, unit: 'MINUTES') {
      waitForQualityGate abortPipeline: true
    }
  }
}
\end{lstlisting}

\subsubsection{Etapa 5: Docker Build}
\begin{lstlisting}[language=groovy]
stage('Docker Build (backend/Dockerfile.jvm)') {
  steps {
    sh "docker build -f Dockerfile.jvm -t ${IMAGE}:${env.BRANCH_NAME} backend"
  }
}
\end{lstlisting}

\subsubsection{Etapa 6: Despliegue por Rama}
\begin{lstlisting}[language=groovy]
stage('Deploy per branch (SQLite)') {
  steps {
    script {
      def port = (env.BRANCH_NAME == 'dev') ? '3001' :
                 (env.BRANCH_NAME == 'uat') ? '3002' : '3003'
      def dbFile = (env.BRANCH_NAME == 'dev') ? '/data/sqlite/dev.db' :
                   (env.BRANCH_NAME == 'uat') ? '/data/sqlite/uat.db' : '/data/sqlite/prod.db'
      def cname = "app_${env.BRANCH_NAME}"

      sh "docker rm -f ${cname} || true"
      sh """
        docker run -d --name ${cname} --network appnet \
          -e DB_FILE='${dbFile}' \
          -p ${port}:${APP_PORT_INTERNAL} \
          -v ${hostDir}:/data/sqlite \
          ${IMAGE}:${env.BRANCH_NAME}
      """
      echo "✅ ${env.BRANCH_NAME}: http://<IP_VM>:${port} usando ${dbFile}"
    }
  }
}
\end{lstlisting}

\subsection{Características del Pipeline}

\begin{itemize}
    \item \textbf{Trigger}: Polling SCM cada 2 minutos
    \item \textbf{Multi-entorno}: Despliegue automático por rama
    \item \textbf{Análisis de Calidad}: Integración con SonarQube
    \item \textbf{Testing}: Ejecución automática de tests
    \item \textbf{Contenedorización}: Build automático de imágenes Docker
\end{itemize}

\section{Despliegue y Contenedores}

\subsection{Diagrama de Despliegue Multi-entorno}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    env/.style={rectangle, draw, fill=blue!20, text width=3cm, text centered, minimum height=1.5cm},
    server/.style={rectangle, draw, fill=gray!20, text width=2cm, text centered, minimum height=1cm},
    db/.style={cylinder, draw, fill=green!20, text width=1.5cm, text centered, minimum height=1cm},
    arrow/.style={->, thick}
]

% Ambientes
\node[env, fill=green!20] (dev) at (-4,6) {DESARROLLO\\Puerto: 3001\\DB: dev.db};
\node[env, fill=yellow!20] (uat) at (0,6) {UAT\\Puerto: 3002\\DB: uat.db};
\node[env, fill=red!20] (prod) at (4,6) {PRODUCCIÓN\\Puerto: 3003\\DB: prod.db};

% Servidores
\node[server] (dev_server) at (-4,4) {Dev\\Server};
\node[server] (uat_server) at (0,4) {UAT\\Server};
\node[server] (prod_server) at (4,4) {Prod\\Server};

% Bases de datos
\node[db] (dev_db) at (-4,2) {SQLite\\dev.db};
\node[db] (uat_db) at (0,2) {SQLite\\uat.db};
\node[db] (prod_db) at (4,2) {SQLite\\prod.db};

% Pipeline
\node[rectangle, draw, fill=purple!20, text width=2cm, text centered] (pipeline) at (0,8) {Jenkins\\Pipeline};

% Flechas
\draw[arrow] (pipeline) -- (dev);
\draw[arrow] (pipeline) -- (uat);
\draw[arrow] (pipeline) -- (prod);
\draw[arrow] (dev) -- (dev_server);
\draw[arrow] (uat) -- (uat_server);
\draw[arrow] (prod) -- (prod_server);
\draw[arrow] (dev_server) -- (dev_db);
\draw[arrow] (uat_server) -- (uat_db);
\draw[arrow] (prod_server) -- (prod_db);

\end{tikzpicture}
\caption{Arquitectura de Despliegue Multi-entorno}
\end{figure}

\subsection{Docker Compose}

\begin{lstlisting}[language=yaml]
services:
  frontend:
    build:
      context: /home/andrespc/Documents/Proyecto2025
      dockerfile: src/Dockerfile
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - app-network

  backend:
    build:
      context: /home/andrespc/Documents/Proyecto2025/backend
      dockerfile: Dockerfile.jvm
    ports:
      - "8080:8080"
    environment:
      - QUARKUS_DATASOURCE_JDBC_URL=jdbc:oracle:thin:@db:1521/XEPDB1
      - QUARKUS_DATASOURCE_USERNAME=C##PROYECTO
      - QUARKUS_DATASOURCE_PASSWORD=Unis
    depends_on:
      - db
    networks:
      - app-network

  db:
    image: container-registry.oracle.com/database/express:latest
    environment:
      - ORACLE_PASSWORD=Unis
    ports:
      - "1521:1521"
    networks:
      - app-network

networks:
  app-network:
    driver: bridge
\end{lstlisting}

\subsection{Configuración de Redes}
\begin{lstlisting}[language=yaml]
networks:
  app-network:
    driver: bridge
\end{lstlisting}

\subsection{Variables de Entorno}

\subsubsection{Backend}
\begin{itemize}
    \item \texttt{QUARKUS\_DATASOURCE\_JDBC\_URL}: URL de conexión a base de datos
    \item \texttt{QUARKUS\_DATASOURCE\_USERNAME}: Usuario de base de datos
    \item \texttt{QUARKUS\_DATASOURCE\_PASSWORD}: Contraseña de base de datos
    \item \texttt{DB\_FILE}: Archivo de base de datos SQLite
\end{itemize}

\subsubsection{Frontend}
\begin{itemize}
    \item \texttt{VITE\_API\_URL}: URL del backend API
\end{itemize}

\section{Iteraciones del Proyecto}

\subsection{Diagrama de Iteraciones del Pipeline}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    iteration/.style={rectangle, draw, fill=blue!20, text width=2.5cm, text centered, minimum height=1cm},
    arrow/.style={->, thick}
]

% Iteraciones del pipeline
\node[iteration] (p1) at (0,8) {Iteración 1\\Configuración Base};
\node[iteration] (p2) at (0,6) {Iteración 2\\Build \& Testing};
\node[iteration] (p3) at (0,4) {Iteración 3\\SonarQube};
\node[iteration] (p4) at (0,2) {Iteración 4\\Docker};
\node[iteration] (p5) at (0,0) {Iteración 5\\Multi-env};
\node[iteration] (p6) at (0,-2) {Iteración 6\\Monitoreo};

% Iteraciones de la aplicación
\node[iteration, fill=green!20] (a1) at (4,8) {Iteración 1\\Fundación};
\node[iteration, fill=green!20] (a2) at (4,6) {Iteración 2\\Roles};
\node[iteration, fill=green!20] (a3) at (4,4) {Iteración 3\\Gestión Médica};
\node[iteration, fill=green!20] (a4) at (4,2) {Iteración 4\\Servicios};
\node[iteration, fill=green!20] (a5) at (4,0) {Iteración 5\\Optimización};
\node[iteration, fill=green!20] (a6) at (4,-2) {Iteración 6\\Monitoreo};

% Flechas
\draw[arrow] (p1) -- (p2);
\draw[arrow] (p2) -- (p3);
\draw[arrow] (p3) -- (p4);
\draw[arrow] (p4) -- (p5);
\draw[arrow] (p5) -- (p6);

\draw[arrow] (a1) -- (a2);
\draw[arrow] (a2) -- (a3);
\draw[arrow] (a3) -- (a4);
\draw[arrow] (a4) -- (a5);
\draw[arrow] (a5) -- (a6);

% Etiquetas
\node[text width=2cm, text centered] at (-2,8) {Pipeline\\CI/CD};
\node[text width=2cm, text centered] at (6,8) {Aplicación\\Hospitalaria};

\end{tikzpicture}
\caption{Iteraciones Paralelas del Pipeline y Aplicación}
\end{figure}

\subsection{Iteración 1: Fundación del Sistema}

\subsubsection{Objetivos}
\begin{itemize}
    \item Establecer la arquitectura base
    \item Implementar autenticación básica
    \item Crear modelos de datos principales
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Configuración inicial de Quarkus
    \item ✅ Configuración inicial de Vue.js
    \item ✅ Modelos de datos básicos (Usuario, Rol, Hospital)
    \item ✅ Sistema de autenticación JWT
    \item ✅ Configuración de base de datos SQLite
\end{itemize}

\subsubsection{Tecnologías Implementadas}
\begin{itemize}
    \item Quarkus 3.8.6
    \item Vue.js 3.5.13
    \item SQLite 3.45.3.0
    \item Hibernate ORM
\end{itemize}

\subsection{Iteración 2: Gestión de Usuarios y Roles}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar sistema de roles completo
    \item Desarrollar gestión de usuarios
    \item Crear interfaces administrativas
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Sistema de roles (Admin, Doctor, Empleado, Paciente)
    \item ✅ Gestión completa de usuarios
    \item ✅ Portal administrativo
    \item ✅ Guards de navegación por roles
    \item ✅ Interfaces de administración
\end{itemize}

\subsubsection{Funcionalidades}
\begin{itemize}
    \item Registro e inicio de sesión
    \item Gestión de usuarios inactivos
    \item Asignación de roles
    \item Portal administrativo completo
\end{itemize}

\subsection{Iteración 3: Gestión Médica Core}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar gestión de pacientes
    \item Desarrollar gestión de doctores
    \item Crear sistema de citas médicas
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Gestión completa de pacientes
    \item ✅ Gestión completa de doctores
    \item ✅ Sistema de citas médicas
    \item ✅ Interfaces específicas por rol
    \item ✅ Validaciones de negocio
\end{itemize}

\subsubsection{Funcionalidades}
\begin{itemize}
    \item CRUD completo para pacientes y doctores
    \item Sistema de citas con validaciones
    \item Interfaces específicas por rol de usuario
    \item Historial médico básico
\end{itemize}

\subsection{Iteración 4: Servicios Médicos y Reportes}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar servicios médicos
    \item Desarrollar sistema de reportes
    \item Crear gestión de medicamentos
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Gestión de servicios médicos
    \item ✅ Sistema de reportes Excel
    \item ✅ Gestión de medicamentos
    \item ✅ Fichas técnicas médicas
    \item ✅ Reportes de moderación
\end{itemize}

\subsubsection{Funcionalidades}
\begin{itemize}
    \item Servicios médicos jerárquicos
    \item Generación de reportes Excel
    \item Gestión de stock de medicamentos
    \item Sistema de fichas técnicas
\end{itemize}

\subsection{Iteración 5: CI/CD y Despliegue}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar pipeline de CI/CD
    \item Configurar despliegue automatizado
    \item Establecer análisis de calidad
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Pipeline Jenkins completo
    \item ✅ Integración con SonarQube
    \item ✅ Despliegue multi-entorno
    \item ✅ Contenedorización Docker
    \item ✅ Testing automatizado
\end{itemize}

\subsubsection{Funcionalidades}
\begin{itemize}
    \item Pipeline automatizado por rama
    \item Análisis de calidad de código
    \item Despliegue en dev, UAT y producción
    \item Testing continuo
\end{itemize}

\subsection{Iteración 6: Optimización y Monitoreo}

\subsubsection{Objetivos}
\begin{itemize}
    \item Optimizar rendimiento
    \item Implementar monitoreo
    \item Mejorar experiencia de usuario
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Optimización de consultas
    \item ✅ Caching de datos
    \item ✅ Monitoreo de aplicación
    \item ✅ Mejoras de UI/UX
    \item ✅ Documentación completa
\end{itemize}

\subsubsection{Funcionalidades}
\begin{itemize}
    \item Optimización de base de datos
    \item Sistema de logs estructurado
    \item Monitoreo de rendimiento
    \item Mejoras en la interfaz de usuario
\end{itemize}

\section{Iteraciones Detalladas del Pipeline}

\subsection{Iteración 1: Configuración Base del Pipeline}

\subsubsection{Objetivos}
\begin{itemize}
    \item Establecer la infraestructura básica de CI/CD
    \item Configurar Jenkins para el proyecto
    \item Implementar checkout automático de código
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Configuración inicial de Jenkins
    \item ✅ Pipeline básico con checkout
    \item ✅ Configuración de triggers
    \item ✅ Estructura de directorios para builds
\end{itemize}

\subsubsection{Configuración Implementada}
\begin{lstlisting}[language=groovy]
pipeline {
  agent any
  environment {
    IMAGE = "miapp"
    APP_PORT_INTERNAL = "8080"
  }
  triggers { pollSCM('H/2 * * * *') }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }
  }
}
\end{lstlisting}

\subsection{Iteración 2: Integración de Build y Testing}

\subsubsection{Objetivos}
\begin{itemize}
    \item Integrar Maven para construcción del backend
    \item Implementar ejecución automática de tests
    \item Configurar reportes de testing
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Stage de build con Maven
    \item ✅ Ejecución automática de tests unitarios
    \item ✅ Reportes de cobertura de código
    \item ✅ Manejo de fallos en tests
\end{itemize}

\subsubsection{Configuración Implementada}
\begin{lstlisting}[language=groovy]
stage('Build & Tests (Maven)') {
  steps {
    sh 'mvn -f backend/pom.xml -B -DskipTests=false clean verify'
  }
  post {
    always {
      publishTestResults testResultsPattern: 'backend/target/surefire-reports/*.xml'
      publishCoverage adapters: [jacocoAdapter('backend/target/site/jacoco/jacoco.xml')]
    }
  }
}
\end{lstlisting}

\subsection{Iteración 3: Análisis de Calidad con SonarQube}

\subsubsection{Objetivos}
\begin{itemize}
    \item Integrar análisis estático de código
    \item Configurar métricas de calidad
    \item Implementar Quality Gate
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Integración con SonarQube
    \item ✅ Análisis automático de código
    \item ✅ Quality Gate configurado
    \item ✅ Reportes de calidad
\end{itemize}

\subsubsection{Configuración Implementada}
\begin{lstlisting}[language=groovy]
stage('SonarQube Analysis') {
  steps {
    withSonarQubeEnv("${SONARQUBE_ENV}") {
      sh 'mvn -f backend/pom.xml -B sonar:sonar'
    }
  }
}

stage('Quality Gate') {
  steps {
    timeout(time: 5, unit: 'MINUTES') {
      waitForQualityGate abortPipeline: true
    }
  }
}
\end{lstlisting}

\subsection{Iteración 4: Contenedorización y Docker}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar construcción de imágenes Docker
    \item Configurar multi-stage builds
    \item Optimizar tamaño de imágenes
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Dockerfile optimizado para producción
    \item ✅ Build automático de imágenes
    \item ✅ Tagging por rama
    \item ✅ Optimización de capas
\end{itemize}

\subsubsection{Configuración Implementada}
\begin{lstlisting}[language=groovy]
stage('Docker Build (backend/Dockerfile.jvm)') {
  steps {
    script {
      def imageTag = "${IMAGE}:${env.BRANCH_NAME}"
      sh "docker build -f Dockerfile.jvm -t ${imageTag} backend"
      
      // Limpiar imágenes antiguas
      sh "docker image prune -f"
    }
  }
}
\end{lstlisting}

\subsection{Iteración 5: Despliegue Multi-entorno}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar despliegue automático por rama
    \item Configurar ambientes separados
    \item Implementar rollback automático
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Despliegue automático por rama
    \item ✅ Configuración de puertos por ambiente
    \item ✅ Gestión de volúmenes de datos
    \item ✅ Health checks post-despliegue
\end{itemize}

\subsection{Iteración 6: Monitoreo y Notificaciones}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar monitoreo de pipeline
    \item Configurar notificaciones
    \item Implementar métricas de despliegue
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Notificaciones de estado del pipeline
    \item ✅ Métricas de tiempo de build
    \item ✅ Monitoreo de salud de aplicaciones
    \item ✅ Alertas de fallos
\end{itemize}

\section{Iteraciones Detalladas de la Aplicación}

\subsection{Iteración 1: Fundación del Sistema}

\subsubsection{Objetivos}
\begin{itemize}
    \item Establecer arquitectura base del sistema
    \item Implementar autenticación básica
    \item Configurar base de datos inicial
\end{itemize}

\subsubsection{Código Clave Implementado}

\textbf{Backend - Usuario Entity}
\begin{lstlisting}[language=java]
@Entity
@Table(name = "USUARIO")
public class Usuario {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_USUARIO")
    private Long idUsuario;
    
    @Column(name = "NOMBRE_USUARIO", nullable = false, length = 50)
    private String nombreUsuario;
    
    @Column(name = "CONTRASENA", nullable = false, length = 128)
    private String contrasena;
    
    @Column(name = "ROL_ID", nullable = false)
    private int rolId;
    
    @Column(name = "CORREO", nullable = false, length = 100)
    private String correo;
    
    @Column(name = "ESTADO")
    private int estado;
    
    @Column(name = "FECHA_CREACTION")
    @Temporal(TemporalType.DATE)
    private Date fechaCreacion;
    
    @Column(name = "IDHOSPITAL")
    private Long idHospital;
}
\end{lstlisting}

\textbf{Frontend - Login Component}
\begin{lstlisting}[language=vue]
<template>
  <form @submit.prevent="login">
    <h2>Iniciar sesión</h2>
    <input v-model="correo" type="email" placeholder="Correo" required />
    <input v-model="contrasena" type="password" placeholder="Contraseña" required />
    <button type="submit">Iniciar sesión</button>
    <p v-if="errorMensaje" class="error">{{ errorMensaje }}</p>
  </form>
</template>

<script setup>
import { ref } from "vue";
import { loginUser } from "@/services/authService.js";
import { useRouter } from "vue-router";
import { setUser } from "@/stores/authStore";

const router = useRouter();
const correo = ref("");
const contrasena = ref("");
const errorMensaje = ref("");

const login = async () => {
  try {
    const { token, user } = await loginUser(correo.value, contrasena.value);
    if (user?.id) {
      setUser(String(user.id), user.roleId ?? 0, router);
      localStorage.setItem("usuarioEmail", correo.value);
      localStorage.setItem("authToken", token);
    }
  } catch (error) {
    errorMensaje.value = "Error al iniciar sesión. Inténtalo nuevamente.";
  }
};
</script>
\end{lstlisting}

\subsection{Iteración 2: Sistema de Roles y Autorización}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar sistema de roles completo
    \item Desarrollar autorización basada en roles
    \item Crear interfaces administrativas
\end{itemize}

\subsubsection{Código Clave Implementado}

\textbf{Backend - Role-based Security}
\begin{lstlisting}[language=java]
@Path("/usuarios")
@RolesAllowed({"Admin"})
public class UsuarioController {
    
    @GET
    @Path("/inactivos")
    @RolesAllowed({"Admin"})
    public List<Usuario> listarUsuariosInactivos() {
        return usuarioService.listarUsuariosInactivos();
    }
    
    @PUT
    @Path("/{id}/activar")
    @RolesAllowed({"Admin"})
    @Transactional
    public Response activarUsuario(@PathParam("id") Long id) {
        usuarioService.activarUsuario(id);
        return Response.ok().build();
    }
}
\end{lstlisting}

\textbf{Frontend - Route Guards}
\begin{lstlisting}[language=typescript]
const ROLES = {
  Admin:    1,
  Doctor:   2,
  Empleado: 3,
  Paciente: 4
} as const;

const requireRole = (allowedRoles: number[]) => (
  to: RouteLocationNormalized,
  from: RouteLocationNormalized,
  next: NavigationGuardNext
) => {
  const userRole = Number(localStorage.getItem("userRole"));
  return allowedRoles.includes(userRole) ? next() : next("/");
};

// Uso en rutas
{
  path: "/admin-portal",
  name: "admin-portal",
  component: AdminPortal,
  beforeEnter: requireRole([ROLES.Admin])
}
\end{lstlisting}

\subsection{Iteración 3: Gestión Médica Core}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar gestión completa de pacientes
    \item Desarrollar gestión de doctores
    \item Crear sistema de citas médicas
\end{itemize}

\subsubsection{Código Clave Implementado}

\textbf{Backend - Paciente Service}
\begin{lstlisting}[language=java]
@ApplicationScoped
public class PacienteService {
    
    @Inject
    PacienteRepository pacienteRepository;
    
    public List<Paciente> getAllPacientes() {
        return pacienteRepository.listAll();
    }
    
    public Optional<Paciente> getPacienteById(Long id) {
        return pacienteRepository.findByIdOptional(id);
    }
    
    @Transactional
    public void registrarPaciente(Paciente paciente) {
        paciente.setEstado("ACTIVO");
        paciente.setFechaCreacion(LocalDateTime.now());
        pacienteRepository.persist(paciente);
    }
    
    @Transactional
    public void actualizarPaciente(Long id, Paciente pacienteActualizado) {
        Paciente paciente = pacienteRepository.findById(id);
        if (paciente != null) {
            paciente.setNombre(pacienteActualizado.getNombre());
            paciente.setApellido(pacienteActualizado.getApellido());
            paciente.setFechaNacimiento(pacienteActualizado.getFechaNacimiento());
            paciente.setGenero(pacienteActualizado.getGenero());
            paciente.setTelefono(pacienteActualizado.getTelefono());
            paciente.setDireccion(pacienteActualizado.getDireccion());
        }
    }
}
\end{lstlisting}

\subsection{Iteración 4: Servicios Médicos y Reportes}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar gestión de servicios médicos
    \item Desarrollar sistema de reportes
    \item Crear gestión de medicamentos
\end{itemize}

\subsubsection{Código Clave Implementado}

\textbf{Backend - Servicio Service}
\begin{lstlisting}[language=java]
@ApplicationScoped
public class ServicioService {
    
    @Inject
    ServicioRepository servicioRepository;
    
    public List<Servicio> listarTodos() {
        return servicioRepository.listAll();
    }
    
    public List<Servicio> listarSubServicios(Long parentId) {
        return servicioRepository.findByParentId(parentId);
    }
    
    @Transactional
    public Servicio agregarServicio(Servicio servicio, Long parentId) {
        if (parentId != null) {
            Servicio servicioPadre = servicioRepository.findById(parentId);
            if (servicioPadre != null) {
                servicio.servicioPadre = servicioPadre;
            }
        }
        servicioRepository.persist(servicio);
        return servicio;
    }
    
    @Transactional
    public void eliminarServicio(Long id) {
        Servicio servicio = servicioRepository.findById(id);
        if (servicio != null) {
            // Verificar si tiene subservicios
            List<Servicio> subservicios = listarSubServicios(id);
            if (!subservicios.isEmpty()) {
                throw new WebApplicationException("No se puede eliminar un servicio que tiene subservicios", Response.Status.BAD_REQUEST);
            }
            servicioRepository.delete(servicio);
        }
    }
}
\end{lstlisting}

\textbf{Backend - Report Generation}
\begin{lstlisting}[language=java]
@ApplicationScoped
public class ReporteService {
    
    public byte[] generarReporteMedicinas() {
        try {
            Workbook workbook = new XSSFWorkbook();
            Sheet sheet = workbook.createSheet("Reporte Medicinas");
            
            // Crear encabezados
            Row headerRow = sheet.createRow(0);
            String[] headers = {"ID", "Nombre", "Descripción", "Precio", "Stock", "Estado"};
            for (int i = 0; i < headers.length; i++) {
                Cell cell = headerRow.createCell(i);
                cell.setCellValue(headers[i]);
            }
            
            // Llenar datos
            List<Medicamento> medicamentos = medicamentoService.getAllMedicamentos();
            int rowNum = 1;
            for (Medicamento medicamento : medicamentos) {
                Row row = sheet.createRow(rowNum++);
                row.createCell(0).setCellValue(medicamento.getId());
                row.createCell(1).setCellValue(medicamento.getNombre());
                row.createCell(2).setCellValue(medicamento.getDescripcion());
                row.createCell(3).setCellValue(medicamento.getPrecio().doubleValue());
                row.createCell(4).setCellValue(medicamento.getStock());
                row.createCell(5).setCellValue(medicamento.getEstado());
            }
            
            // Convertir a bytes
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            workbook.write(outputStream);
            workbook.close();
            
            return outputStream.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException("Error generando reporte", e);
        }
    }
}
\end{lstlisting}

\section{Testing y Calidad}

\subsection{Testing Backend}

\subsubsection{Unit Tests}
\begin{lstlisting}[language=java]
@QuarkusTest
public class UsuarioServiceTest {
    
    @Inject
    UsuarioService usuarioService;
    
    @Test
    public void testRegistrarUsuario() {
        // Test implementation
    }
}
\end{lstlisting}

\subsubsection{Integration Tests}
\begin{lstlisting}[language=java]
@QuarkusIntegrationTest
public class UsuarioResourceIT {
    
    @Test
    public void testLoginEndpoint() {
        given()
            .contentType(ContentType.JSON)
            .body(loginRequest)
        .when()
            .post("/usuarios/login")
        .then()
            .statusCode(200);
    }
}
\end{lstlisting}

\subsection{Testing Frontend}

\subsubsection{Unit Tests (Vitest)}
\begin{lstlisting}[language=typescript]
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import LoginForm from '@/components/LoginForm.vue'

describe('LoginForm', () => {
  it('renders properly', () => {
    const wrapper = mount(LoginForm)
    expect(wrapper.text()).toContain('Iniciar sesión')
  })
})
\end{lstlisting}

\subsubsection{E2E Tests (Playwright)}
\begin{lstlisting}[language=typescript]
import { test, expect } from '@playwright/test'

test('login flow', async ({ page }) => {
  await page.goto('/login')
  await page.fill('[data-testid="email"]', 'test@example.com')
  await page.fill('[data-testid="password"]', 'password')
  await page.click('[data-testid="login-button"]')
  await expect(page).toHaveURL('/admin-portal')
})
\end{lstlisting}

\subsection{Métricas de Calidad}

\subsubsection{SonarQube Metrics}
\begin{itemize}
    \item \textbf{Coverage}: >80\%
    \item \textbf{Duplicated Lines}: <3\%
    \item \textbf{Maintainability Rating}: A
    \item \textbf{Reliability Rating}: A
    \item \textbf{Security Rating}: A
\end{itemize}

\subsubsection{Code Quality Standards}
\begin{itemize}
    \item \textbf{Cyclomatic Complexity}: <10
    \item \textbf{Cognitive Complexity}: <15
    \item \textbf{Lines per Method}: <50
    \item \textbf{Methods per Class}: <20
\end{itemize}

\section{Monitoreo y Logs}

\subsection{Logging Backend}

\subsubsection{Configuración de Logs}
\begin{lstlisting}[language=properties]
# Logging configuration
quarkus.log.level=INFO
quarkus.log.category."com.unis".level=DEBUG
quarkus.log.console.enable=true
quarkus.log.file.enable=true
quarkus.log.file.path=logs/application.log
\end{lstlisting}

\subsubsection{Logging en Código}
\begin{lstlisting}[language=java]
@ApplicationScoped
public class UsuarioService {
    
    private static final Logger LOG = Logger.getLogger(UsuarioService.class);
    
    public Usuario registrarUsuario(Usuario usuario) {
        LOG.info("Registrando nuevo usuario: " + usuario.getCorreo());
        // Implementation
        LOG.info("Usuario registrado exitosamente: " + usuario.getId());
        return usuario;
    }
}
\end{lstlisting}

\subsection{Monitoreo de Aplicación}

\subsubsection{Health Checks}
\begin{lstlisting}[language=java]
@ApplicationScoped
public class DatabaseHealthCheck implements HealthCheck {
    
    @Override
    public HealthCheckResponse call() {
        return HealthCheckResponse.up()
            .withData("database", "SQLite")
            .withData("status", "connected")
            .build();
    }
}
\end{lstlisting}

\subsubsection{Métricas de Rendimiento}
\begin{itemize}
    \item \textbf{Response Time}: <200ms promedio
    \item \textbf{Throughput}: >1000 requests/min
    \item \textbf{Error Rate}: <1\%
    \item \textbf{Uptime}: >99.9\%
\end{itemize}

\section{Seguridad}

\subsection{Diagrama de Seguridad y Autenticación}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    layer/.style={rectangle, draw, fill=blue!20, text width=3cm, text centered, minimum height=1cm},
    component/.style={rectangle, draw, fill=green!20, text width=2cm, text centered, minimum height=0.8cm},
    arrow/.style={->, thick}
]

% Capas de seguridad
\node[layer, fill=green!20] (frontend) at (0,6) {Frontend\\Security};
\node[layer, fill=yellow!20] (backend) at (0,4) {Backend\\Security};
\node[layer, fill=red!20] (database) at (0,2) {Database\\Security};
\node[layer, fill=purple!20] (infra) at (0,0) {Infrastructure\\Security};

% Componentes frontend
\node[component] (jwt) at (-3,6) {JWT Token\\Storage};
\node[component] (guards) at (0,6) {Route\\Guards};
\node[component] (validation) at (3,6) {Role\\Validation};

% Componentes backend
\node[component] (jwt_val) at (-3,4) {JWT\\Validation};
\node[component] (rbac) at (0,4) {Role-based\\Access};
\node[component] (input_val) at (3,4) {Input\\Validation};

% Componentes database
\node[component] (encryption) at (-3,2) {SQLite\\Encryption};
\node[component] (access) at (0,2) {Access\\Control};
\node[component] (audit) at (3,2) {Audit\\Logging};

% Componentes infraestructura
\node[component] (docker) at (-3,0) {Docker\\Security};
\node[component] (network) at (0,0) {Network\\Isolation};
\node[component] (secrets) at (3,0) {Secrets\\Management};

% Flechas
\draw[arrow] (jwt) -- (jwt_val);
\draw[arrow] (guards) -- (rbac);
\draw[arrow] (validation) -- (input_val);
\draw[arrow] (jwt_val) -- (encryption);
\draw[arrow] (rbac) -- (access);
\draw[arrow] (input_val) -- (audit);
\draw[arrow] (encryption) -- (docker);
\draw[arrow] (access) -- (network);
\draw[arrow] (audit) -- (secrets);

\end{tikzpicture}
\caption{Arquitectura de Seguridad Multi-capa}
\end{figure}

\subsection{Autenticación y Autorización}

\subsubsection{JWT Configuration}
\begin{lstlisting}[language=properties]
mp.jwt.verify.publickey.location=META-INF/resources/publicKey.pem
mp.jwt.verify.issuer=quarkus
\end{lstlisting}

\subsubsection{Role-based Access Control}
\begin{lstlisting}[language=java]
@RolesAllowed({"Admin", "Doctor"})
@GET
@Path("/doctores")
public List<Doctor> obtenerDoctores() {
    return doctorService.getAllDoctores();
}
\end{lstlisting}

\subsection{Seguridad de Datos}

\subsubsection{Validación de Entrada}
\begin{lstlisting}[language=java]
@POST
@Path("/usuarios")
@Transactional
public Response registrarUsuario(@Valid Usuario usuario) {
    // Validation handled by @Valid annotation
    Usuario registrado = usuarioService.registrarUsuario(usuario);
    return Response.status(Response.Status.CREATED).entity(registrado).build();
}
\end{lstlisting}

\subsubsection{CORS Configuration}
\begin{lstlisting}[language=properties]
quarkus.http.cors=true
quarkus.http.cors.origins=http://localhost:5173,http://127.0.0.1:5173
quarkus.http.cors.methods=GET,POST,PUT,DELETE,OPTIONS
quarkus.http.cors.headers=accept,authorization,content-type,x-requested-with
\end{lstlisting}

\subsection{Mejores Prácticas de Seguridad}

\begin{enumerate}
    \item \textbf{Validación de Entrada}: Todas las entradas son validadas
    \item \textbf{Sanitización}: Datos sanitizados antes de almacenar
    \item \textbf{Encriptación}: Contraseñas encriptadas con BCrypt
    \item \textbf{HTTPS}: Comunicación encriptada en producción
    \item \textbf{Rate Limiting}: Límites de requests por usuario
    \item \textbf{Audit Logging}: Registro de actividades críticas
\end{enumerate}

\section{Configuración y Despliegue}

\subsection{Configuración de Desarrollo}

\subsubsection{Requisitos del Sistema}
\begin{itemize}
    \item Java 17+
    \item Maven 3.6+
    \item Node.js 18+
    \item Docker 20.10+
    \item Git 2.30+
\end{itemize}

\subsubsection{Configuración Inicial}
\begin{lstlisting}[language=bash]
# Clonar repositorio
git clone <repository-url>
cd Proyecto2025-Hospital2-sofi

# Configurar backend
cd backend
./mvnw quarkus:dev -Dquarkus.profile=dev

# Configurar frontend
cd ../src
npm install
npm run dev
\end{lstlisting}

\subsubsection{Variables de Entorno}
\begin{lstlisting}[language=bash]
# Backend
export DB_FILE=./data/dev.db
export QUARKUS_PROFILE=dev

# Frontend
export VITE_API_URL=http://localhost:8080
\end{lstlisting}

\subsection{Configuración de Producción}

\subsubsection{Despliegue con Docker Compose}
\begin{lstlisting}[language=bash]
# Construir y ejecutar
docker-compose up --build

# Ejecutar en background
docker-compose up -d --build
\end{lstlisting}

\subsubsection{Configuración de Servidor}
\begin{lstlisting}[language=bash]
# Crear directorios de datos
mkdir -p /srv/sqlite/{dev,uat,prod}

# Configurar permisos
chown -R app:app /srv/sqlite/
chmod 755 /srv/sqlite/
\end{lstlisting}

\subsection{Configuración de Jenkins}

\subsubsection{Plugins Requeridos}
\begin{itemize}
    \item Pipeline Plugin
    \item Docker Plugin
    \item SonarQube Scanner Plugin
    \item Git Plugin
\end{itemize}

\subsubsection{Configuración de SonarQube}
\begin{lstlisting}[language=properties]
sonar.projectKey=proyecto2025-hospital2-sofi
sonar.projectName=Proyecto2025 Hospital2 SOFI
sonar.projectVersion=1.0.0
sonar.sources=backend/src/main/java
sonar.tests=backend/src/test/java
sonar.java.binaries=backend/target/classes
sonar.java.libraries=backend/target/dependency/*.jar
\end{lstlisting}

\section{Conclusión}

El \textbf{PROYECTO2025-HOSPITAL2-SOFI} representa una solución integral de gestión hospitalaria que combina tecnologías modernas con mejores prácticas de desarrollo. El sistema ha sido diseñado con una arquitectura escalable, mantenible y segura que cumple con los requisitos de un entorno hospitalario real.

\subsection{Logros Principales}

\begin{enumerate}
    \item \textbf{Arquitectura Robusta}: Implementación de patrones arquitectónicos probados
    \item \textbf{Seguridad Integral}: Sistema de autenticación y autorización completo
    \item \textbf{Escalabilidad}: Diseño que permite crecimiento futuro
    \item \textbf{Calidad de Código}: Implementación de testing y análisis de calidad
    \item \textbf{CI/CD Automatizado}: Pipeline completo de integración y despliegue
    \item \textbf{Multi-entorno}: Soporte para desarrollo, UAT y producción
\end{enumerate}

\subsection{Tecnologías Implementadas}

\begin{itemize}
    \item \textbf{Backend}: Quarkus 3.8.6, Java 17, Hibernate ORM, SQLite
    \item \textbf{Frontend}: Vue.js 3.5.13, TypeScript, Tailwind CSS, Pinia
    \item \textbf{DevOps}: Jenkins, Docker, SonarQube
    \item \textbf{Testing}: JUnit 5, Vitest, Playwright
    \item \textbf{Documentación}: Markdown, TikZ diagrams
\end{itemize}

\subsection{Beneficios del Sistema}

\begin{enumerate}
    \item \textbf{Eficiencia Operativa}: Automatización de procesos hospitalarios
    \item \textbf{Mejor Experiencia de Usuario}: Interfaces intuitivas y responsivas
    \item \textbf{Gestión Centralizada}: Administración unificada de todos los recursos
    \item \textbf{Trazabilidad}: Registro completo de actividades y cambios
    \item \textbf{Flexibilidad}: Sistema adaptable a diferentes necesidades hospitalarias
\end{enumerate}

\subsection{Próximos Pasos}

\begin{enumerate}
    \item \textbf{Expansión de Funcionalidades}: Implementación de módulos adicionales
    \item \textbf{Integración Externa}: Conexión con sistemas hospitalarios existentes
    \item \textbf{Analytics}: Implementación de dashboards y reportes avanzados
    \item \textbf{Mobile App}: Desarrollo de aplicación móvil complementaria
    \item \textbf{Cloud Migration}: Migración a infraestructura en la nube
\end{enumerate}

El proyecto demuestra la capacidad de desarrollar sistemas complejos utilizando tecnologías modernas y metodologías ágiles, estableciendo una base sólida para el crecimiento futuro del sistema de gestión hospitalaria.

\subsection{Resumen de Iteraciones}

\subsubsection{Pipeline CI/CD - Resumen}
\begin{enumerate}
    \item \textbf{Iteración 1}: Configuración base del pipeline
    \item \textbf{Iteración 2}: Integración de build y testing
    \item \textbf{Iteración 3}: Análisis de calidad con SonarQube
    \item \textbf{Iteración 4}: Contenedorización y Docker
    \item \textbf{Iteración 5}: Despliegue multi-entorno
    \item \textbf{Iteración 6}: Monitoreo y notificaciones
\end{enumerate}

\subsubsection{Aplicación - Resumen}
\begin{enumerate}
    \item \textbf{Iteración 1}: Fundación del sistema
    \item \textbf{Iteración 2}: Sistema de roles y autorización
    \item \textbf{Iteración 3}: Gestión médica core
    \item \textbf{Iteración 4}: Servicios médicos y reportes
    \item \textbf{Iteración 5}: Optimización y performance
    \item \textbf{Iteración 6}: Monitoreo y observabilidad
\end{enumerate}

\subsection{Métricas de Éxito}
\begin{itemize}
    \item \textbf{Cobertura de Tests}: >80\%
    \item \textbf{Tiempo de Build}: <5 minutos
    \item \textbf{Tiempo de Despliegue}: <2 minutos
    \item \textbf{Tiempo de Respuesta}: <200ms
    \item \textbf{Uptime}: >99.9\%
    \item \textbf{Calidad de Código}: Rating A en SonarQube
\end{itemize}

---

\textbf{Documento generado automáticamente} \\
\textbf{Fecha}: \today \\
\textbf{Versión}: 1.0.0 \\
\textbf{Proyecto}: PROYECTO2025-HOSPITAL2-SOFI

\end{document}

