\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

% Paquetes para diagramas TikZ
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{shapes,arrows,positioning,fit,backgrounds,calc,decorations.pathreplacing}
\pgfplotsset{compat=1.18}

% Configuración de página
\geometry{margin=2.5cm}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{PROYECTO2025-HOSPITAL2-SOFI}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Configuración de colores para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{azulBrand}{RGB}{0,102,204}
\definecolor{grisClaro}{RGB}{238,238,238}
\definecolor{naranjaAlerta}{RGB}{235,137,52}
\definecolor{verdeOk}{RGB}{60,179,113}

% Configuración de listings
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Configuración de títulos
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

\begin{document}

% Portada
\begin{titlepage}
\centering
\vspace*{2cm}

{\Huge\bfseries DOCUMENTACIÓN COMPLETA}\\[0.5cm]
{\Huge\bfseries PROYECTO2025-HOSPITAL2-SOFI}\\[2cm]

{\Large Sistema Integral de Gestión Hospitalaria}\\[1cm]

\vspace{2cm}

\begin{tabular}{ll}
\textbf{Versión:} & 1.1.0 \\
\textbf{Fecha:} & \today \\
\textbf{Tecnologías:} & Quarkus, Vue.js 3, SQLite \\
\textbf{Arquitectura:} & Microservicios, CI/CD \\
\end{tabular}

\vfill

{\large Sistema desarrollado con tecnologías modernas para la gestión integral de hospitales}

\end{titlepage}

\tableofcontents
\newpage

\section{Introducción}

El \textbf{PROYECTO2025-HOSPITAL2-SOFI} es un sistema integral de gestión hospitalaria desarrollado con tecnologías modernas que incluye un backend basado en Quarkus (Java), un frontend desarrollado en Vue.js 3, y un pipeline de CI/CD automatizado consolidado en Google Cloud Build (con Jenkins como referencia histórica). El sistema está diseñado para manejar múltiples aspectos de la gestión hospitalaria incluyendo usuarios, pacientes, doctores, empleados, citas médicas, historias clínicas, servicios médicos y reportes.

\subsection{Características Principales}
\begin{itemize}
    \item \textbf{Arquitectura de Microservicios}: Backend modular con Quarkus
    \item \textbf{Frontend Moderno}: Vue.js 3 con TypeScript y Tailwind CSS
    \item \textbf{Base de Datos}: SQLite con soporte multi-entorno (dev, uat, prod)
    \item \textbf{Autenticación y Autorización}: Sistema de roles basado en JWT
    \item \textbf{CI/CD Automatizado}: Pipeline en Google Cloud Build con análisis de calidad y despliegue multi-entorno
    \item \textbf{Contenedorización}: Docker para despliegue consistente
    \item \textbf{Multi-entorno}: Soporte para desarrollo, UAT y producción
\end{itemize}

\section{Arquitectura del Sistema}

\subsection{Arquitectura General}

El sistema sigue una arquitectura de \textbf{3 capas} con separación clara de responsabilidades:

\begin{enumerate}
    \item \textbf{Capa de Presentación}: Vue.js 3, Tailwind CSS, Router, Pinia Store
    \item \textbf{Capa de Lógica de Negocio}: Quarkus Backend, REST APIs, Service Layer
    \item \textbf{Capa de Datos}: SQLite Database, Hibernate ORM, JPA Entities
\end{enumerate}

\subsection{Diagrama de Arquitectura General}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    box/.style={rectangle, draw, fill=blue!20, text width=3cm, text centered, minimum height=1cm},
    layer/.style={rectangle, draw, fill=gray!20, text width=12cm, text centered, minimum height=1.5cm},
    arrow/.style={->, thick}
]

% Capa de Presentación
\node[layer, fill=green!20] (presentation) at (0,6) {CAPA DE PRESENTACIÓN};
\node[box] (vue) at (-3,5) {Vue.js 3\\Frontend};
\node[box] (tailwind) at (0,5) {Tailwind CSS\\Styling};
\node[box] (router) at (3,5) {Router\\Guards};

% Capa de Aplicación
\node[layer, fill=yellow!20] (application) at (0,3.5) {CAPA DE LÓGICA DE NEGOCIO};
\node[box] (quarkus) at (-3,2.5) {Quarkus\\Backend};
\node[box] (rest) at (0,2.5) {REST APIs\\Resources};
\node[box] (service) at (3,2.5) {Service\\Layer};

% Capa de Datos
\node[layer, fill=red!20] (data) at (0,1) {CAPA DE DATOS};
\node[box] (sqlite) at (-3,0) {SQLite\\Database};
\node[box] (hibernate) at (0,0) {Hibernate ORM\\JPA Entities};
\node[box] (panache) at (3,0) {Panache\\Repos};

% Flechas
\draw[arrow] (vue) -- (quarkus);
\draw[arrow] (tailwind) -- (rest);
\draw[arrow] (router) -- (service);
\draw[arrow] (quarkus) -- (sqlite);
\draw[arrow] (rest) -- (hibernate);
\draw[arrow] (service) -- (panache);

\end{tikzpicture}
\caption{Arquitectura de 3 Capas del Sistema}
\end{figure}

\subsection{Patrones Arquitectónicos Implementados}

\begin{enumerate}
    \item \textbf{MVC (Model-View-Controller)}
    \begin{itemize}
        \item \textbf{Model}: Entidades JPA en el backend
        \item \textbf{View}: Componentes Vue.js en el frontend
        \item \textbf{Controller}: Resources REST en Quarkus
    \end{itemize}
    
    \item \textbf{Repository Pattern}
    \begin{itemize}
        \item Implementado con Panache para acceso a datos
        \item Separación entre lógica de negocio y acceso a datos
    \end{itemize}
    
    \item \textbf{Service Layer Pattern}
    \begin{itemize}
        \item Servicios de negocio que encapsulan la lógica compleja
        \item Separación entre controladores y repositorios
    \end{itemize}
    
    \item \textbf{Dependency Injection}
    \begin{itemize}
        \item Quarkus CDI para inyección de dependencias
        \item Vue.js Composition API para gestión de estado
    \end{itemize}
\end{enumerate}

\section{Componentes del Sistema}

\subsection{Backend (Quarkus)}

\subsubsection{Estructura de Paquetes}
\begin{lstlisting}[language=bash]
com.unis/
├── controller/          # Controladores REST principales
├── resource/            # Recursos REST específicos
├── service/            # Lógica de negocio
├── repository/          # Acceso a datos
├── model/              # Entidades JPA
├── dto/                # Objetos de transferencia de datos
└── config/             # Configuraciones
\end{lstlisting}

\subsubsection{Tecnologías Backend}
\begin{itemize}
    \item \textbf{Framework}: Quarkus 3.8.6
    \item \textbf{Java}: OpenJDK 17+
    \item \textbf{ORM}: Hibernate ORM con Panache
    \item \textbf{Base de Datos}: SQLite 3.45.3.0
    \item \textbf{API}: RESTEasy Reactive
    \item \textbf{Testing}: JUnit 5, Mockito, RestAssured
    \item \textbf{Documentación}: Apache POI para reportes Excel
\end{itemize}

\subsection{Frontend (Vue.js 3)}

\subsubsection{Estructura de Componentes}
\begin{lstlisting}[language=bash]
src/
├── components/         # Componentes reutilizables
├── views/              # Vistas principales
│   ├── admin/          # Vistas administrativas
│   ├── doctores/       # Vistas para doctores
│   └── vistasSimuladas/ # Vistas simuladas
├── services/           # Servicios de API
├── stores/             # Gestión de estado (Pinia)
├── router/             # Configuración de rutas
└── assets/             # Recursos estáticos
\end{lstlisting}

\subsubsection{Tecnologías Frontend}
\begin{itemize}
    \item \textbf{Framework}: Vue.js 3.5.13
    \item \textbf{Lenguaje}: TypeScript 5.7.3
    \item \textbf{Styling}: Tailwind CSS 4.0.6
    \item \textbf{Estado}: Pinia 2.3.1
    \item \textbf{HTTP Client}: Axios 1.7.9
    \item \textbf{Testing}: Vitest, Playwright
    \item \textbf{Build Tool}: Vite 6.0.11
\end{itemize}

\section{Base de Datos}

\subsection{Modelo de Datos}

El sistema utiliza SQLite como base de datos principal con las siguientes entidades principales:

\subsubsection{Entidades Core}
\begin{itemize}
    \item \textbf{Usuario}: Gestión de cuentas de usuario
    \item \textbf{Rol}: Definición de roles del sistema
    \item \textbf{Hospital}: Información de hospitales
    \item \textbf{UserAcc}: Cuentas de usuario con autenticación
\end{itemize}

\subsubsection{Entidades de Negocio}
\begin{itemize}
    \item \textbf{Paciente}: Información de pacientes
    \item \textbf{Doctor}: Información de doctores
    \item \textbf{Empleado}: Información de empleados
    \item \textbf{Cita}: Citas médicas
    \item \textbf{Historia}: Historias clínicas
    \item \textbf{Servicio}: Servicios médicos
    \item \textbf{Medicamento}: Medicamentos y recetas
    \item \textbf{FichaTecnica}: Fichas técnicas médicas
\end{itemize}

\subsubsection{Entidades de Soporte}
\begin{itemize}
    \item \textbf{UsuarioInter}: Usuarios de interconexión
    \item \textbf{SolicitudHospital}: Solicitudes de hospitales
    \item \textbf{Receta}: Recetas médicas
    \item \textbf{RecetaMedicamento}: Relación receta-medicamento
\end{itemize}

\subsection{Diagrama de Base de Datos (ERD)}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    entity/.style={rectangle, draw, fill=blue!20, text width=2.5cm, text centered, minimum height=1cm},
    relationship/.style={diamond, draw, fill=green!20, text width=1cm, text centered, minimum height=0.8cm},
    attribute/.style={ellipse, draw, fill=yellow!20, text width=1.5cm, text centered, minimum height=0.6cm}
]

% Entidades principales
\node[entity] (usuario) at (0,8) {USUARIO};
\node[entity] (rol) at (-4,6) {ROL};
\node[entity] (hospital) at (4,6) {HOSPITAL};
\node[entity] (paciente) at (-2,4) {PACIENTE};
\node[entity] (doctor) at (2,4) {DOCTOR};
\node[entity] (empleado) at (0,2) {EMPLEADO};
\node[entity] (cita) at (-2,0) {CITA};
\node[entity] (historia) at (2,0) {HISTORIA};
\node[entity] (servicio) at (-4,-2) {SERVICIO};
\node[entity] (medicamento) at (0,-2) {MEDICAMENTO};
\node[entity] (receta) at (4,-2) {RECETA};

% Relaciones
\node[relationship] (r1) at (-2,7) {tiene};
\node[relationship] (r2) at (2,7) {pertenece};
\node[relationship] (r3) at (-1,6) {es};
\node[relationship] (r4) at (1,6) {es};
\node[relationship] (r5) at (0,3) {es};
\node[relationship] (r6) at (-1,2) {agenda};
\node[relationship] (r7) at (1,2) {crea};
\node[relationship] (r8) at (-3,-1) {contiene};
\node[relationship] (r9) at (2,-1) {incluye};

% Conexiones
\draw (usuario) -- (r1) -- (rol);
\draw (usuario) -- (r2) -- (hospital);
\draw (usuario) -- (r3) -- (paciente);
\draw (usuario) -- (r4) -- (doctor);
\draw (usuario) -- (r5) -- (empleado);
\draw (paciente) -- (r6) -- (cita);
\draw (doctor) -- (r6) -- (cita);
\draw (doctor) -- (r7) -- (historia);
\draw (cita) -- (r8) -- (receta);
\draw (receta) -- (r9) -- (medicamento);

% Atributos principales
\node[attribute] (id_usuario) at (-2,9) {ID\_USUARIO};
\node[attribute] (nombre) at (2,9) {NOMBRE};
\node[attribute] (correo) at (0,10) {CORREO};

\draw (id_usuario) -- (usuario);
\draw (nombre) -- (usuario);
\draw (correo) -- (usuario);

\end{tikzpicture}
\caption{Diagrama de Entidad-Relación (ERD) del Sistema}
\end{figure}

\subsection{Configuración Multi-entorno}

\begin{lstlisting}[language=properties]
# Desarrollo
%dev.quarkus.datasource.jdbc.url=jdbc:sqlite:./data/dev.db
%dev.quarkus.hibernate-orm.database.generation=update

# UAT
%uat.quarkus.datasource.jdbc.url=jdbc:sqlite:./data/uat.db
%uat.quarkus.hibernate-orm.database.generation=validate

# Producción
%prod.quarkus.datasource.jdbc.url=jdbc:sqlite:./data/prod.db
%prod.quarkus.hibernate-orm.database.generation=validate
\end{lstlisting}

\section{API REST}

\subsection{Endpoints Principales}

\subsubsection{Autenticación y Usuarios}
\begin{lstlisting}[language=bash]
POST /usuarios/login              # Inicio de sesión
POST /usuarios/registro           # Registro de usuarios
GET  /usuarios/inactivos         # Usuarios inactivos
GET  /usuarios/roles             # Lista de roles
PUT  /usuarios/{id}/activar      # Activar usuario
\end{lstlisting}

\subsubsection{Gestión de Pacientes}
\begin{lstlisting}[language=bash]
GET    /paciente                 # Listar pacientes
GET    /paciente/{id}            # Obtener paciente
POST   /paciente                 # Crear paciente
PUT    /paciente/{id}            # Actualizar paciente
DELETE /paciente/{id}            # Eliminar paciente
\end{lstlisting}

\subsubsection{Gestión de Doctores}
\begin{lstlisting}[language=bash]
GET    /doctor                   # Listar doctores
GET    /doctor/{id}              # Obtener doctor
POST   /doctor                   # Crear doctor
PUT    /doctor/{id}              # Actualizar doctor
DELETE /doctor/{id}              # Eliminar doctor
\end{lstlisting}

\subsubsection{Gestión de Empleados}
\begin{lstlisting}[language=bash]
GET    /empleado                 # Listar empleados
GET    /empleado/{id}            # Obtener empleado
POST   /empleado                 # Crear empleado
PUT    /empleado/{id}            # Actualizar empleado
DELETE /empleado/{id}            # Eliminar empleado
\end{lstlisting}

\subsubsection{Citas Médicas}
\begin{lstlisting}[language=bash]
GET    /citas                    # Listar citas
GET    /citas/{id}               # Obtener cita
POST   /citas                    # Crear cita
PUT    /citas/{id}              # Actualizar cita
DELETE /citas/{id}              # Eliminar cita
\end{lstlisting}

\subsubsection{Servicios Médicos}
\begin{lstlisting}[language=bash]
GET    /api/servicios            # Listar servicios
GET    /api/servicios/{id}/subservicios # Subservicios
POST   /api/servicios            # Crear servicio
PUT    /api/servicios/{id}       # Actualizar servicio
DELETE /api/servicios/{id}       # Eliminar servicio
\end{lstlisting}

\subsection{Características de la API}

\begin{itemize}
    \item \textbf{Formato}: JSON
    \item \textbf{Autenticación}: JWT Bearer Token
    \item \textbf{CORS}: Configurado para desarrollo local
    \item \textbf{Validación}: Validación de entrada en todos los endpoints
    \item \textbf{Manejo de Errores}: Respuestas HTTP estándar con mensajes descriptivos
\end{itemize}

\section{Frontend}

\subsection{Arquitectura de Componentes}

\subsubsection{Estructura de Rutas}
\begin{lstlisting}[language=typescript]
// Rutas públicas
/                    # Página principal
/login              # Inicio de sesión
/signup             # Registro
/faq                # Preguntas frecuentes
/servicios-medicos  # Servicios médicos
/historia           # Historia del hospital
/doctores           # Catálogo de doctores

// Rutas por rol
/admin-portal       # Portal administrativo (Admin)
/my-account-*       # Cuentas personales por rol
/recetas           # Recetas médicas (Doctor)
/consultar-historial # Historial (Paciente)
\end{lstlisting}

\subsubsection{Sistema de Roles}
\begin{lstlisting}[language=typescript]
const ROLES = {
  Admin:    1,
  Doctor:   2,
  Empleado: 3,
  Paciente: 4
} as const;
\end{lstlisting}

\subsubsection{Guards de Navegación}
\begin{itemize}
    \item \textbf{requireAuth}: Verifica autenticación
    \item \textbf{requireRole}: Verifica roles específicos
    \item \textbf{Redirección automática}: Basada en roles de usuario
\end{itemize}

\subsection{Servicios Frontend}

\subsubsection{Servicios de API}
\begin{itemize}
    \item \textbf{authService.js}: Autenticación y autorización
    \item \textbf{pacienteService.js}: Gestión de pacientes
    \item \textbf{doctorService.js}: Gestión de doctores
    \item \textbf{citaService.js}: Gestión de citas
    \item \textbf{historiaService.js}: Historias clínicas
    \item \textbf{servicioService.js}: Servicios médicos
\end{itemize}

\subsubsection{Gestión de Estado}
\begin{itemize}
    \item \textbf{Pinia Store}: Estado global de la aplicación
    \item \textbf{authStore.ts}: Estado de autenticación
    \item \textbf{LocalStorage}: Persistencia de sesión
\end{itemize}

\section{Pipeline de CI/CD}

Esta sección conserva la documentación del pipeline original en Jenkins como referencia histórica, mientras que la Fase~III detalla el pipeline vigente en Google Cloud Build (ver Sección~\ref{fig:pipeline-gcp}).

\subsection{Diagrama de Pipeline CI/CD}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    stage/.style={rectangle, draw, fill=blue!20, text width=2.5cm, text centered, minimum height=1cm},
    decision/.style={diamond, draw, fill=red!20, text width=2cm, text centered, minimum height=1cm},
    arrow/.style={->, thick},
    success/.style={fill=green!20},
    failure/.style={fill=red!20}
]

% Etapas del pipeline
\node[stage] (checkout) at (0,8) {Checkout\\Code};
\node[stage] (build) at (0,6) {Build \&\\Tests};
\node[stage] (sonar) at (0,4) {SonarQube\\Analysis};
\node[decision] (quality) at (0,2) {Quality\\Gate};
\node[stage] (docker) at (0,0) {Docker\\Build};
\node[stage] (deploy) at (0,-2) {Deploy\\Multi-env};

% Etapas paralelas
\node[stage, success] (unit) at (-3,6) {Unit\\Tests};
\node[stage, success] (integration) at (3,6) {Integration\\Tests};

% Ambientes de despliegue
\node[stage, fill=green!20] (dev) at (-3,-2) {Dev\\:3001};
\node[stage, fill=yellow!20] (uat) at (0,-4) {UAT\\:3002};
\node[stage, fill=red!20] (prod) at (3,-2) {Prod\\:3003};

% Flechas principales
\draw[arrow] (checkout) -- (build);
\draw[arrow] (build) -- (sonar);
\draw[arrow] (sonar) -- (quality);
\draw[arrow] (quality) -- node[right] {Pass} (docker);
\draw[arrow] (quality) -- node[left] {Fail} ++(-2,0) -- ++(0,-3) -- (checkout);
\draw[arrow] (docker) -- (deploy);

% Flechas paralelas
\draw[arrow] (build) -- (unit);
\draw[arrow] (build) -- (integration);
\draw[arrow] (unit) -- (sonar);
\draw[arrow] (integration) -- (sonar);

% Flechas de despliegue
\draw[arrow] (deploy) -- (dev);
\draw[arrow] (deploy) -- (uat);
\draw[arrow] (deploy) -- (prod);

\end{tikzpicture}
\caption{Pipeline de CI/CD con Análisis de Calidad}
\end{figure}

\subsection{Configuración Jenkins}

El pipeline está configurado en \texttt{Dockerfile.jenkins} con las siguientes etapas:

\subsubsection{Etapa 1: Checkout}
\begin{lstlisting}[language=groovy]
stage('Checkout') {
  steps { checkout scm }
}
\end{lstlisting}

\subsubsection{Etapa 2: Build \& Tests}
\begin{lstlisting}[language=groovy]
stage('Build & Tests (Maven)') {
  steps {
    sh 'mvn -f backend/pom.xml -B -DskipTests=false clean verify'
  }
}
\end{lstlisting}

\subsubsection{Etapa 3: Análisis de Calidad}
\begin{lstlisting}[language=groovy]
stage('SonarQube Analysis') {
  steps {
    withSonarQubeEnv("${SONARQUBE_ENV}") {
      sh 'mvn -f backend/pom.xml -B sonar:sonar'
    }
  }
}
\end{lstlisting}

\subsubsection{Etapa 4: Quality Gate}
\begin{lstlisting}[language=groovy]
stage('Quality Gate') {
  steps {
    timeout(time: 5, unit: 'MINUTES') {
      waitForQualityGate abortPipeline: true
    }
  }
}
\end{lstlisting}

\subsubsection{Etapa 5: Docker Build}
\begin{lstlisting}[language=groovy]
stage('Docker Build (backend/Dockerfile.jvm)') {
  steps {
    sh "docker build -f Dockerfile.jvm -t ${IMAGE}:${env.BRANCH_NAME} backend"
  }
}
\end{lstlisting}

\subsubsection{Etapa 6: Despliegue por Rama}
\begin{lstlisting}[language=groovy]
stage('Deploy per branch (SQLite)') {
  steps {
    script {
      def port = (env.BRANCH_NAME == 'dev') ? '3001' :
                 (env.BRANCH_NAME == 'uat') ? '3002' : '3003'
      def dbFile = (env.BRANCH_NAME == 'dev') ? '/data/sqlite/dev.db' :
                   (env.BRANCH_NAME == 'uat') ? '/data/sqlite/uat.db' : '/data/sqlite/prod.db'
      def cname = "app_${env.BRANCH_NAME}"

      sh "docker rm -f ${cname} || true"
      sh """
        docker run -d --name ${cname} --network appnet \
          -e DB_FILE='${dbFile}' \
          -p ${port}:${APP_PORT_INTERNAL} \
          -v ${hostDir}:/data/sqlite \
          ${IMAGE}:${env.BRANCH_NAME}
      """
      echo "✅ ${env.BRANCH_NAME}: http://<IP_VM>:${port} usando ${dbFile}"
    }
  }
}
\end{lstlisting}

\subsection{Características del Pipeline}

\begin{itemize}
    \item \textbf{Trigger}: Polling SCM cada 2 minutos
    \item \textbf{Multi-entorno}: Despliegue automático por rama
    \item \textbf{Análisis de Calidad}: Integración con SonarQube
    \item \textbf{Testing}: Ejecución automática de tests
    \item \textbf{Contenedorización}: Build automático de imágenes Docker
\end{itemize}

\section{Despliegue y Contenedores}

\subsection{Diagrama de Despliegue Multi-entorno}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    env/.style={rectangle, draw, fill=blue!20, text width=3cm, text centered, minimum height=1.5cm},
    server/.style={rectangle, draw, fill=gray!20, text width=2cm, text centered, minimum height=1cm},
    db/.style={cylinder, draw, fill=green!20, text width=1.5cm, text centered, minimum height=1cm},
    arrow/.style={->, thick}
]

% Ambientes
\node[env, fill=green!20] (dev) at (-4,6) {DESARROLLO\\Puerto: 3001\\DB: dev.db};
\node[env, fill=yellow!20] (uat) at (0,6) {UAT\\Puerto: 3002\\DB: uat.db};
\node[env, fill=red!20] (prod) at (4,6) {PRODUCCIÓN\\Puerto: 3003\\DB: prod.db};

% Servidores
\node[server] (dev_server) at (-4,4) {Dev\\Server};
\node[server] (uat_server) at (0,4) {UAT\\Server};
\node[server] (prod_server) at (4,4) {Prod\\Server};

% Bases de datos
\node[db] (dev_db) at (-4,2) {SQLite\\dev.db};
\node[db] (uat_db) at (0,2) {SQLite\\uat.db};
\node[db] (prod_db) at (4,2) {SQLite\\prod.db};

% Pipeline
\node[rectangle, draw, fill=purple!20, text width=2cm, text centered] (pipeline) at (0,8) {Jenkins\\Pipeline};

% Flechas
\draw[arrow] (pipeline) -- (dev);
\draw[arrow] (pipeline) -- (uat);
\draw[arrow] (pipeline) -- (prod);
\draw[arrow] (dev) -- (dev_server);
\draw[arrow] (uat) -- (uat_server);
\draw[arrow] (prod) -- (prod_server);
\draw[arrow] (dev_server) -- (dev_db);
\draw[arrow] (uat_server) -- (uat_db);
\draw[arrow] (prod_server) -- (prod_db);

\end{tikzpicture}
\caption{Arquitectura de Despliegue Multi-entorno}
\end{figure}

\subsection{Docker Compose}

\begin{lstlisting}[language=yaml]
services:
  frontend:
    build:
      context: /home/andrespc/Documents/Proyecto2025
      dockerfile: src/Dockerfile
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - app-network

  backend:
    build:
      context: /home/andrespc/Documents/Proyecto2025/backend
      dockerfile: Dockerfile.jvm
    ports:
      - "8080:8080"
    environment:
      - QUARKUS_DATASOURCE_JDBC_URL=jdbc:oracle:thin:@db:1521/XEPDB1
      - QUARKUS_DATASOURCE_USERNAME=C##PROYECTO
      - QUARKUS_DATASOURCE_PASSWORD=Unis
    depends_on:
      - db
    networks:
      - app-network

  db:
    image: container-registry.oracle.com/database/express:latest
    environment:
      - ORACLE_PASSWORD=Unis
    ports:
      - "1521:1521"
    networks:
      - app-network

networks:
  app-network:
    driver: bridge
\end{lstlisting}

\subsection{Configuración de Redes}
\begin{lstlisting}[language=yaml]
networks:
  app-network:
    driver: bridge
\end{lstlisting}

\subsection{Variables de Entorno}

\subsubsection{Backend}
\begin{itemize}
    \item \texttt{QUARKUS\_DATASOURCE\_JDBC\_URL}: URL de conexión a base de datos
    \item \texttt{QUARKUS\_DATASOURCE\_USERNAME}: Usuario de base de datos
    \item \texttt{QUARKUS\_DATASOURCE\_PASSWORD}: Contraseña de base de datos
    \item \texttt{DB\_FILE}: Archivo de base de datos SQLite
\end{itemize}

\subsubsection{Frontend}
\begin{itemize}
    \item \texttt{VITE\_API\_URL}: URL del backend API
\end{itemize}

\section{Iteraciones del Proyecto}

\subsection{Diagrama de Iteraciones del Pipeline}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    iteration/.style={rectangle, draw, fill=blue!20, text width=2.5cm, text centered, minimum height=1cm},
    arrow/.style={->, thick}
]

% Iteraciones del pipeline
\node[iteration] (p1) at (0,8) {Iteración 1\\Configuración Base};
\node[iteration] (p2) at (0,6) {Iteración 2\\Build \& Testing};
\node[iteration] (p3) at (0,4) {Iteración 3\\SonarQube};
\node[iteration] (p4) at (0,2) {Iteración 4\\Docker};
\node[iteration] (p5) at (0,0) {Iteración 5\\Multi-env};
\node[iteration] (p6) at (0,-2) {Iteración 6\\Monitoreo};

% Iteraciones de la aplicación
\node[iteration, fill=green!20] (a1) at (4,8) {Iteración 1\\Fundación};
\node[iteration, fill=green!20] (a2) at (4,6) {Iteración 2\\Roles};
\node[iteration, fill=green!20] (a3) at (4,4) {Iteración 3\\Gestión Médica};
\node[iteration, fill=green!20] (a4) at (4,2) {Iteración 4\\Servicios};
\node[iteration, fill=green!20] (a5) at (4,0) {Iteración 5\\Optimización};
\node[iteration, fill=green!20] (a6) at (4,-2) {Iteración 6\\Monitoreo};

% Flechas
\draw[arrow] (p1) -- (p2);
\draw[arrow] (p2) -- (p3);
\draw[arrow] (p3) -- (p4);
\draw[arrow] (p4) -- (p5);
\draw[arrow] (p5) -- (p6);

\draw[arrow] (a1) -- (a2);
\draw[arrow] (a2) -- (a3);
\draw[arrow] (a3) -- (a4);
\draw[arrow] (a4) -- (a5);
\draw[arrow] (a5) -- (a6);

% Etiquetas
\node[text width=2cm, text centered] at (-2,8) {Pipeline\\CI/CD};
\node[text width=2cm, text centered] at (6,8) {Aplicación\\Hospitalaria};

\end{tikzpicture}
\caption{Iteraciones Paralelas del Pipeline y Aplicación}
\end{figure}

\subsection{Iteración 1: Fundación del Sistema}

\subsubsection{Objetivos}
\begin{itemize}
    \item Establecer la arquitectura base
    \item Implementar autenticación básica
    \item Crear modelos de datos principales
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Configuración inicial de Quarkus
    \item ✅ Configuración inicial de Vue.js
    \item ✅ Modelos de datos básicos (Usuario, Rol, Hospital)
    \item ✅ Sistema de autenticación JWT
    \item ✅ Configuración de base de datos SQLite
\end{itemize}

\subsubsection{Tecnologías Implementadas}
\begin{itemize}
    \item Quarkus 3.8.6
    \item Vue.js 3.5.13
    \item SQLite 3.45.3.0
    \item Hibernate ORM
\end{itemize}

\subsection{Iteración 2: Gestión de Usuarios y Roles}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar sistema de roles completo
    \item Desarrollar gestión de usuarios
    \item Crear interfaces administrativas
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Sistema de roles (Admin, Doctor, Empleado, Paciente)
    \item ✅ Gestión completa de usuarios
    \item ✅ Portal administrativo
    \item ✅ Guards de navegación por roles
    \item ✅ Interfaces de administración
\end{itemize}

\subsubsection{Funcionalidades}
\begin{itemize}
    \item Registro e inicio de sesión
    \item Gestión de usuarios inactivos
    \item Asignación de roles
    \item Portal administrativo completo
\end{itemize}

\subsection{Iteración 3: Gestión Médica Core}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar gestión de pacientes
    \item Desarrollar gestión de doctores
    \item Crear sistema de citas médicas
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Gestión completa de pacientes
    \item ✅ Gestión completa de doctores
    \item ✅ Sistema de citas médicas
    \item ✅ Interfaces específicas por rol
    \item ✅ Validaciones de negocio
\end{itemize}

\subsubsection{Funcionalidades}
\begin{itemize}
    \item CRUD completo para pacientes y doctores
    \item Sistema de citas con validaciones
    \item Interfaces específicas por rol de usuario
    \item Historial médico básico
\end{itemize}

\subsection{Iteración 4: Servicios Médicos y Reportes}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar servicios médicos
    \item Desarrollar sistema de reportes
    \item Crear gestión de medicamentos
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Gestión de servicios médicos
    \item ✅ Sistema de reportes Excel
    \item ✅ Gestión de medicamentos
    \item ✅ Fichas técnicas médicas
    \item ✅ Reportes de moderación
\end{itemize}

\subsubsection{Funcionalidades}
\begin{itemize}
    \item Servicios médicos jerárquicos
    \item Generación de reportes Excel
    \item Gestión de stock de medicamentos
    \item Sistema de fichas técnicas
\end{itemize}

\subsection{Iteración 5: CI/CD y Despliegue}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar pipeline de CI/CD
    \item Configurar despliegue automatizado
    \item Establecer análisis de calidad
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Pipeline Jenkins completo
    \item ✅ Integración con SonarQube
    \item ✅ Despliegue multi-entorno
    \item ✅ Contenedorización Docker
    \item ✅ Testing automatizado
\end{itemize}

\subsubsection{Funcionalidades}
\begin{itemize}
    \item Pipeline automatizado por rama
    \item Análisis de calidad de código
    \item Despliegue en dev, UAT y producción
    \item Testing continuo
\end{itemize}

\subsection{Iteración 6: Optimización y Monitoreo}

\subsubsection{Objetivos}
\begin{itemize}
    \item Optimizar rendimiento
    \item Implementar monitoreo
    \item Mejorar experiencia de usuario
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Optimización de consultas
    \item ✅ Caching de datos
    \item ✅ Monitoreo de aplicación
    \item ✅ Mejoras de UI/UX
    \item ✅ Documentación completa
\end{itemize}

\subsubsection{Funcionalidades}
\begin{itemize}
    \item Optimización de base de datos
    \item Sistema de logs estructurado
    \item Monitoreo de rendimiento
    \item Mejoras en la interfaz de usuario
\end{itemize}

\section{Iteraciones Detalladas del Pipeline}

\subsection{Iteración 1: Configuración Base del Pipeline}

\subsubsection{Objetivos}
\begin{itemize}
    \item Establecer la infraestructura básica de CI/CD
    \item Configurar Jenkins para el proyecto
    \item Implementar checkout automático de código
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Configuración inicial de Jenkins
    \item ✅ Pipeline básico con checkout
    \item ✅ Configuración de triggers
    \item ✅ Estructura de directorios para builds
\end{itemize}

\subsubsection{Configuración Implementada}
\begin{lstlisting}[language=groovy]
pipeline {
  agent any
  environment {
    IMAGE = "miapp"
    APP_PORT_INTERNAL = "8080"
  }
  triggers { pollSCM('H/2 * * * *') }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }
  }
}
\end{lstlisting}

\subsection{Iteración 2: Integración de Build y Testing}

\subsubsection{Objetivos}
\begin{itemize}
    \item Integrar Maven para construcción del backend
    \item Implementar ejecución automática de tests
    \item Configurar reportes de testing
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Stage de build con Maven
    \item ✅ Ejecución automática de tests unitarios
    \item ✅ Reportes de cobertura de código
    \item ✅ Manejo de fallos en tests
\end{itemize}

\subsubsection{Configuración Implementada}
\begin{lstlisting}[language=groovy]
stage('Build & Tests (Maven)') {
  steps {
    sh 'mvn -f backend/pom.xml -B -DskipTests=false clean verify'
  }
  post {
    always {
      publishTestResults testResultsPattern: 'backend/target/surefire-reports/*.xml'
      publishCoverage adapters: [jacocoAdapter('backend/target/site/jacoco/jacoco.xml')]
    }
  }
}
\end{lstlisting}

\subsection{Iteración 3: Análisis de Calidad con SonarQube}

\subsubsection{Objetivos}
\begin{itemize}
    \item Integrar análisis estático de código
    \item Configurar métricas de calidad
    \item Implementar Quality Gate
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Integración con SonarQube
    \item ✅ Análisis automático de código
    \item ✅ Quality Gate configurado
    \item ✅ Reportes de calidad
\end{itemize}

\subsubsection{Configuración Implementada}
\begin{lstlisting}[language=groovy]
stage('SonarQube Analysis') {
  steps {
    withSonarQubeEnv("${SONARQUBE_ENV}") {
      sh 'mvn -f backend/pom.xml -B sonar:sonar'
    }
  }
}

stage('Quality Gate') {
  steps {
    timeout(time: 5, unit: 'MINUTES') {
      waitForQualityGate abortPipeline: true
    }
  }
}
\end{lstlisting}

\subsection{Iteración 4: Contenedorización y Docker}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar construcción de imágenes Docker
    \item Configurar multi-stage builds
    \item Optimizar tamaño de imágenes
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Dockerfile optimizado para producción
    \item ✅ Build automático de imágenes
    \item ✅ Tagging por rama
    \item ✅ Optimización de capas
\end{itemize}

\subsubsection{Configuración Implementada}
\begin{lstlisting}[language=groovy]
stage('Docker Build (backend/Dockerfile.jvm)') {
  steps {
    script {
      def imageTag = "${IMAGE}:${env.BRANCH_NAME}"
      sh "docker build -f Dockerfile.jvm -t ${imageTag} backend"
      
      // Limpiar imágenes antiguas
      sh "docker image prune -f"
    }
  }
}
\end{lstlisting}

\subsection{Iteración 5: Despliegue Multi-entorno}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar despliegue automático por rama
    \item Configurar ambientes separados
    \item Implementar rollback automático
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Despliegue automático por rama
    \item ✅ Configuración de puertos por ambiente
    \item ✅ Gestión de volúmenes de datos
    \item ✅ Health checks post-despliegue
\end{itemize}

\subsection{Iteración 6: Monitoreo y Notificaciones}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar monitoreo de pipeline
    \item Configurar notificaciones
    \item Implementar métricas de despliegue
\end{itemize}

\subsubsection{Entregables}
\begin{itemize}
    \item ✅ Notificaciones de estado del pipeline
    \item ✅ Métricas de tiempo de build
    \item ✅ Monitoreo de salud de aplicaciones
    \item ✅ Alertas de fallos
\end{itemize}

\section{Iteraciones Detalladas de la Aplicación}

\subsection{Iteración 1: Fundación del Sistema}

\subsubsection{Objetivos}
\begin{itemize}
    \item Establecer arquitectura base del sistema
    \item Implementar autenticación básica
    \item Configurar base de datos inicial
\end{itemize}

\subsubsection{Código Clave Implementado}

\textbf{Backend - Usuario Entity}
\begin{lstlisting}[language=java]
@Entity
@Table(name = "USUARIO")
public class Usuario {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID_USUARIO")
    private Long idUsuario;
    
    @Column(name = "NOMBRE_USUARIO", nullable = false, length = 50)
    private String nombreUsuario;
    
    @Column(name = "CONTRASENA", nullable = false, length = 128)
    private String contrasena;
    
    @Column(name = "ROL_ID", nullable = false)
    private int rolId;
    
    @Column(name = "CORREO", nullable = false, length = 100)
    private String correo;
    
    @Column(name = "ESTADO")
    private int estado;
    
    @Column(name = "FECHA_CREACTION")
    @Temporal(TemporalType.DATE)
    private Date fechaCreacion;
    
    @Column(name = "IDHOSPITAL")
    private Long idHospital;
}
\end{lstlisting}

\textbf{Frontend - Login Component}
\begin{lstlisting}[language=vue]
<template>
  <form @submit.prevent="login">
    <h2>Iniciar sesión</h2>
    <input v-model="correo" type="email" placeholder="Correo" required />
    <input v-model="contrasena" type="password" placeholder="Contraseña" required />
    <button type="submit">Iniciar sesión</button>
    <p v-if="errorMensaje" class="error">{{ errorMensaje }}</p>
  </form>
</template>

<script setup>
import { ref } from "vue";
import { loginUser } from "@/services/authService.js";
import { useRouter } from "vue-router";
import { setUser } from "@/stores/authStore";

const router = useRouter();
const correo = ref("");
const contrasena = ref("");
const errorMensaje = ref("");

const login = async () => {
  try {
    const { token, user } = await loginUser(correo.value, contrasena.value);
    if (user?.id) {
      setUser(String(user.id), user.roleId ?? 0, router);
      localStorage.setItem("usuarioEmail", correo.value);
      localStorage.setItem("authToken", token);
    }
  } catch (error) {
    errorMensaje.value = "Error al iniciar sesión. Inténtalo nuevamente.";
  }
};
</script>
\end{lstlisting}

\subsection{Iteración 2: Sistema de Roles y Autorización}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar sistema de roles completo
    \item Desarrollar autorización basada en roles
    \item Crear interfaces administrativas
\end{itemize}

\subsubsection{Código Clave Implementado}

\textbf{Backend - Role-based Security}
\begin{lstlisting}[language=java]
@Path("/usuarios")
@RolesAllowed({"Admin"})
public class UsuarioController {
    
    @GET
    @Path("/inactivos")
    @RolesAllowed({"Admin"})
    public List<Usuario> listarUsuariosInactivos() {
        return usuarioService.listarUsuariosInactivos();
    }
    
    @PUT
    @Path("/{id}/activar")
    @RolesAllowed({"Admin"})
    @Transactional
    public Response activarUsuario(@PathParam("id") Long id) {
        usuarioService.activarUsuario(id);
        return Response.ok().build();
    }
}
\end{lstlisting}

\textbf{Frontend - Route Guards}
\begin{lstlisting}[language=typescript]
const ROLES = {
  Admin:    1,
  Doctor:   2,
  Empleado: 3,
  Paciente: 4
} as const;

const requireRole = (allowedRoles: number[]) => (
  to: RouteLocationNormalized,
  from: RouteLocationNormalized,
  next: NavigationGuardNext
) => {
  const userRole = Number(localStorage.getItem("userRole"));
  return allowedRoles.includes(userRole) ? next() : next("/");
};

// Uso en rutas
{
  path: "/admin-portal",
  name: "admin-portal",
  component: AdminPortal,
  beforeEnter: requireRole([ROLES.Admin])
}
\end{lstlisting}

\subsection{Iteración 3: Gestión Médica Core}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar gestión completa de pacientes
    \item Desarrollar gestión de doctores
    \item Crear sistema de citas médicas
\end{itemize}

\subsubsection{Código Clave Implementado}

\textbf{Backend - Paciente Service}
\begin{lstlisting}[language=java]
@ApplicationScoped
public class PacienteService {
    
    @Inject
    PacienteRepository pacienteRepository;
    
    public List<Paciente> getAllPacientes() {
        return pacienteRepository.listAll();
    }
    
    public Optional<Paciente> getPacienteById(Long id) {
        return pacienteRepository.findByIdOptional(id);
    }
    
    @Transactional
    public void registrarPaciente(Paciente paciente) {
        paciente.setEstado("ACTIVO");
        paciente.setFechaCreacion(LocalDateTime.now());
        pacienteRepository.persist(paciente);
    }
    
    @Transactional
    public void actualizarPaciente(Long id, Paciente pacienteActualizado) {
        Paciente paciente = pacienteRepository.findById(id);
        if (paciente != null) {
            paciente.setNombre(pacienteActualizado.getNombre());
            paciente.setApellido(pacienteActualizado.getApellido());
            paciente.setFechaNacimiento(pacienteActualizado.getFechaNacimiento());
            paciente.setGenero(pacienteActualizado.getGenero());
            paciente.setTelefono(pacienteActualizado.getTelefono());
            paciente.setDireccion(pacienteActualizado.getDireccion());
        }
    }
}
\end{lstlisting}

\subsection{Iteración 4: Servicios Médicos y Reportes}

\subsubsection{Objetivos}
\begin{itemize}
    \item Implementar gestión de servicios médicos
    \item Desarrollar sistema de reportes
    \item Crear gestión de medicamentos
\end{itemize}

\subsubsection{Código Clave Implementado}

\textbf{Backend - Servicio Service}
\begin{lstlisting}[language=java]
@ApplicationScoped
public class ServicioService {
    
    @Inject
    ServicioRepository servicioRepository;
    
    public List<Servicio> listarTodos() {
        return servicioRepository.listAll();
    }
    
    public List<Servicio> listarSubServicios(Long parentId) {
        return servicioRepository.findByParentId(parentId);
    }
    
    @Transactional
    public Servicio agregarServicio(Servicio servicio, Long parentId) {
        if (parentId != null) {
            Servicio servicioPadre = servicioRepository.findById(parentId);
            if (servicioPadre != null) {
                servicio.servicioPadre = servicioPadre;
            }
        }
        servicioRepository.persist(servicio);
        return servicio;
    }
    
    @Transactional
    public void eliminarServicio(Long id) {
        Servicio servicio = servicioRepository.findById(id);
        if (servicio != null) {
            // Verificar si tiene subservicios
            List<Servicio> subservicios = listarSubServicios(id);
            if (!subservicios.isEmpty()) {
                throw new WebApplicationException("No se puede eliminar un servicio que tiene subservicios", Response.Status.BAD_REQUEST);
            }
            servicioRepository.delete(servicio);
        }
    }
}
\end{lstlisting}

\textbf{Backend - Report Generation}
\begin{lstlisting}[language=java]
@ApplicationScoped
public class ReporteService {
    
    public byte[] generarReporteMedicinas() {
        try {
            Workbook workbook = new XSSFWorkbook();
            Sheet sheet = workbook.createSheet("Reporte Medicinas");
            
            // Crear encabezados
            Row headerRow = sheet.createRow(0);
            String[] headers = {"ID", "Nombre", "Descripción", "Precio", "Stock", "Estado"};
            for (int i = 0; i < headers.length; i++) {
                Cell cell = headerRow.createCell(i);
                cell.setCellValue(headers[i]);
            }
            
            // Llenar datos
            List<Medicamento> medicamentos = medicamentoService.getAllMedicamentos();
            int rowNum = 1;
            for (Medicamento medicamento : medicamentos) {
                Row row = sheet.createRow(rowNum++);
                row.createCell(0).setCellValue(medicamento.getId());
                row.createCell(1).setCellValue(medicamento.getNombre());
                row.createCell(2).setCellValue(medicamento.getDescripcion());
                row.createCell(3).setCellValue(medicamento.getPrecio().doubleValue());
                row.createCell(4).setCellValue(medicamento.getStock());
                row.createCell(5).setCellValue(medicamento.getEstado());
            }
            
            // Convertir a bytes
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            workbook.write(outputStream);
            workbook.close();
            
            return outputStream.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException("Error generando reporte", e);
        }
    }
}
\end{lstlisting}

\section{Testing y Calidad}

\subsection{Testing Backend}

\subsubsection{Unit Tests}
\begin{lstlisting}[language=java]
@QuarkusTest
public class UsuarioServiceTest {
    
    @Inject
    UsuarioService usuarioService;
    
    @Test
    public void testRegistrarUsuario() {
        // Test implementation
    }
}
\end{lstlisting}

\subsubsection{Integration Tests}
\begin{lstlisting}[language=java]
@QuarkusIntegrationTest
public class UsuarioResourceIT {
    
    @Test
    public void testLoginEndpoint() {
        given()
            .contentType(ContentType.JSON)
            .body(loginRequest)
        .when()
            .post("/usuarios/login")
        .then()
            .statusCode(200);
    }
}
\end{lstlisting}

\subsection{Testing Frontend}

\subsubsection{Unit Tests (Vitest)}
\begin{lstlisting}[language=typescript]
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import LoginForm from '@/components/LoginForm.vue'

describe('LoginForm', () => {
  it('renders properly', () => {
    const wrapper = mount(LoginForm)
    expect(wrapper.text()).toContain('Iniciar sesión')
  })
})
\end{lstlisting}

\subsubsection{E2E Tests (Playwright)}
\begin{lstlisting}[language=typescript]
import { test, expect } from '@playwright/test'

test('login flow', async ({ page }) => {
  await page.goto('/login')
  await page.fill('[data-testid="email"]', 'test@example.com')
  await page.fill('[data-testid="password"]', 'password')
  await page.click('[data-testid="login-button"]')
  await expect(page).toHaveURL('/admin-portal')
})
\end{lstlisting}

\subsection{Métricas de Calidad}

\subsubsection{SonarQube Metrics}
\begin{itemize}
    \item \textbf{Coverage}: >80\%
    \item \textbf{Duplicated Lines}: <3\%
    \item \textbf{Maintainability Rating}: A
    \item \textbf{Reliability Rating}: A
    \item \textbf{Security Rating}: A
\end{itemize}

\subsubsection{Code Quality Standards}
\begin{itemize}
    \item \textbf{Cyclomatic Complexity}: <10
    \item \textbf{Cognitive Complexity}: <15
    \item \textbf{Lines per Method}: <50
    \item \textbf{Methods per Class}: <20
\end{itemize}

\section{Monitoreo y Logs}

\subsection{Logging Backend}

\subsubsection{Configuración de Logs}
\begin{lstlisting}[language=properties]
# Logging configuration
quarkus.log.level=INFO
quarkus.log.category."com.unis".level=DEBUG
quarkus.log.console.enable=true
quarkus.log.file.enable=true
quarkus.log.file.path=logs/application.log
\end{lstlisting}

\subsubsection{Logging en Código}
\begin{lstlisting}[language=java]
@ApplicationScoped
public class UsuarioService {
    
    private static final Logger LOG = Logger.getLogger(UsuarioService.class);
    
    public Usuario registrarUsuario(Usuario usuario) {
        LOG.info("Registrando nuevo usuario: " + usuario.getCorreo());
        // Implementation
        LOG.info("Usuario registrado exitosamente: " + usuario.getId());
        return usuario;
    }
}
\end{lstlisting}

\subsection{Monitoreo de Aplicación}

\subsubsection{Health Checks}
\begin{lstlisting}[language=java]
@ApplicationScoped
public class DatabaseHealthCheck implements HealthCheck {
    
    @Override
    public HealthCheckResponse call() {
        return HealthCheckResponse.up()
            .withData("database", "SQLite")
            .withData("status", "connected")
            .build();
    }
}
\end{lstlisting}

\subsubsection{Métricas de Rendimiento}
\begin{itemize}
    \item \textbf{Response Time}: <200ms promedio
    \item \textbf{Throughput}: >1000 requests/min
    \item \textbf{Error Rate}: <1\%
    \item \textbf{Uptime}: >99.9\%
\end{itemize}

\section{Seguridad}

\subsection{Diagrama de Seguridad y Autenticación}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    layer/.style={rectangle, draw, fill=blue!20, text width=3cm, text centered, minimum height=1cm},
    component/.style={rectangle, draw, fill=green!20, text width=2cm, text centered, minimum height=0.8cm},
    arrow/.style={->, thick}
]

% Capas de seguridad
\node[layer, fill=green!20] (frontend) at (0,6) {Frontend\\Security};
\node[layer, fill=yellow!20] (backend) at (0,4) {Backend\\Security};
\node[layer, fill=red!20] (database) at (0,2) {Database\\Security};
\node[layer, fill=purple!20] (infra) at (0,0) {Infrastructure\\Security};

% Componentes frontend
\node[component] (jwt) at (-3,6) {JWT Token\\Storage};
\node[component] (guards) at (0,6) {Route\\Guards};
\node[component] (validation) at (3,6) {Role\\Validation};

% Componentes backend
\node[component] (jwt_val) at (-3,4) {JWT\\Validation};
\node[component] (rbac) at (0,4) {Role-based\\Access};
\node[component] (input_val) at (3,4) {Input\\Validation};

% Componentes database
\node[component] (encryption) at (-3,2) {SQLite\\Encryption};
\node[component] (access) at (0,2) {Access\\Control};
\node[component] (audit) at (3,2) {Audit\\Logging};

% Componentes infraestructura
\node[component] (docker) at (-3,0) {Docker\\Security};
\node[component] (network) at (0,0) {Network\\Isolation};
\node[component] (secrets) at (3,0) {Secrets\\Management};

% Flechas
\draw[arrow] (jwt) -- (jwt_val);
\draw[arrow] (guards) -- (rbac);
\draw[arrow] (validation) -- (input_val);
\draw[arrow] (jwt_val) -- (encryption);
\draw[arrow] (rbac) -- (access);
\draw[arrow] (input_val) -- (audit);
\draw[arrow] (encryption) -- (docker);
\draw[arrow] (access) -- (network);
\draw[arrow] (audit) -- (secrets);

\end{tikzpicture}
\caption{Arquitectura de Seguridad Multi-capa}
\end{figure}

\subsection{Autenticación y Autorización}

\subsubsection{JWT Configuration}
\begin{lstlisting}[language=properties]
mp.jwt.verify.publickey.location=META-INF/resources/publicKey.pem
mp.jwt.verify.issuer=quarkus
\end{lstlisting}

\subsubsection{Role-based Access Control}
\begin{lstlisting}[language=java]
@RolesAllowed({"Admin", "Doctor"})
@GET
@Path("/doctores")
public List<Doctor> obtenerDoctores() {
    return doctorService.getAllDoctores();
}
\end{lstlisting}

\subsection{Seguridad de Datos}

\subsubsection{Validación de Entrada}
\begin{lstlisting}[language=java]
@POST
@Path("/usuarios")
@Transactional
public Response registrarUsuario(@Valid Usuario usuario) {
    // Validation handled by @Valid annotation
    Usuario registrado = usuarioService.registrarUsuario(usuario);
    return Response.status(Response.Status.CREATED).entity(registrado).build();
}
\end{lstlisting}

\subsubsection{CORS Configuration}
\begin{lstlisting}[language=properties]
quarkus.http.cors=true
quarkus.http.cors.origins=http://localhost:5173,http://127.0.0.1:5173
quarkus.http.cors.methods=GET,POST,PUT,DELETE,OPTIONS
quarkus.http.cors.headers=accept,authorization,content-type,x-requested-with
\end{lstlisting}

\subsection{Mejores Prácticas de Seguridad}

\begin{enumerate}
    \item \textbf{Validación de Entrada}: Todas las entradas son validadas
    \item \textbf{Sanitización}: Datos sanitizados antes de almacenar
    \item \textbf{Encriptación}: Contraseñas encriptadas con BCrypt
    \item \textbf{HTTPS}: Comunicación encriptada en producción
    \item \textbf{Rate Limiting}: Límites de requests por usuario
    \item \textbf{Audit Logging}: Registro de actividades críticas
\end{enumerate}

\section{Configuración y Despliegue}

\subsection{Configuración de Desarrollo}

\subsubsection{Requisitos del Sistema}
\begin{itemize}
    \item Java 17+
    \item Maven 3.6+
    \item Node.js 18+
    \item Docker 20.10+
    \item Git 2.30+
\end{itemize}

\subsubsection{Configuración Inicial}
\begin{lstlisting}[language=bash]
# Clonar repositorio
git clone <repository-url>
cd Proyecto2025-Hospital2-sofi

# Configurar backend
cd backend
./mvnw quarkus:dev -Dquarkus.profile=dev

# Configurar frontend
cd ../src
npm install
npm run dev
\end{lstlisting}

\subsubsection{Variables de Entorno}
\begin{lstlisting}[language=bash]
# Backend
export DB_FILE=./data/dev.db
export QUARKUS_PROFILE=dev

# Frontend
export VITE_API_URL=http://localhost:8080
\end{lstlisting}

\subsection{Configuración de Producción}

\subsubsection{Despliegue con Docker Compose}
\begin{lstlisting}[language=bash]
# Construir y ejecutar
docker-compose up --build

# Ejecutar en background
docker-compose up -d --build
\end{lstlisting}

\subsubsection{Configuración de Servidor}
\begin{lstlisting}[language=bash]
# Crear directorios de datos
mkdir -p /srv/sqlite/{dev,uat,prod}

# Configurar permisos
chown -R app:app /srv/sqlite/
chmod 755 /srv/sqlite/
\end{lstlisting}

\subsection{Configuración de Jenkins}

\subsubsection{Plugins Requeridos}
\begin{itemize}
    \item Pipeline Plugin
    \item Docker Plugin
    \item SonarQube Scanner Plugin
    \item Git Plugin
\end{itemize}

\subsubsection{Configuración de SonarQube}
\begin{lstlisting}[language=properties]
sonar.projectKey=proyecto2025-hospital2-sofi
sonar.projectName=Proyecto2025 Hospital2 SOFI
sonar.projectVersion=1.0.0
sonar.sources=backend/src/main/java
sonar.tests=backend/src/test/java
sonar.java.binaries=backend/target/classes
sonar.java.libraries=backend/target/dependency/*.jar
\end{lstlisting}

\newpage
\section{Fase III -- Documentación y Mejoras Requeridas}

Esta sección amplía la documentación existente para cubrir las observaciones de la Fase~III. Se incluyen actualizaciones de diagramas, documentación ADD, matrices de deuda técnica, análisis de performance, sizing de infraestructura multi-proveedor y una síntesis ejecutiva para la alta dirección.

\subsection{Cumplimiento de recomendaciones previas}

\begin{itemize}[leftmargin=1.2cm]
    \item Se actualizó el diagrama general del sistema incorporando los componentes de observabilidad, identidad federada y almacenamiento seguro de respaldos.
    \item Se ejecutó un proceso ADD completo con nueve iteraciones alineadas a escenarios de calidad específicos para disponibilidad, desempeño, seguridad, escalabilidad, mantenibilidad y experiencia de usuario.
    \item Se documentaron los patrones arquitectónicos aplicados en frontend y backend, destacando la arquitectura hexagonal, fachada de APIs y estrategias CQRS ligeras.
    \item Se agregaron matrices de deuda técnica diferenciadas para pipeline CI/CD y aplicación, priorizando acciones de remediación.
    \item Se incorporó un estudio comparativo de infraestructura en Google Cloud, AWS y Azure, con costos anuales estimados para ambientes de desarrollo, QA y producción.
    \item Se preparó un resumen ejecutivo con los puntos clave del proyecto para exposición ante un comité directivo.
\end{itemize}

\subsection{Diagrama general del sistema actualizado}

La Figura~\ref{fig:diag-general-fase3} resume la arquitectura lógica incorporando los servicios de identidad (Keycloak), observabilidad, integraciones externas y almacenamiento de respaldos.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[font=\small, node distance=1.45cm]
        \tikzstyle{caja}=[rectangle, draw=azulBrand, thick, rounded corners=3pt, fill=grisClaro, minimum width=4.2cm, minimum height=1.1cm, align=center]
        \tikzstyle{externo}=[rectangle, draw=black, dashed, rounded corners=3pt, minimum width=4cm, minimum height=1cm, align=center]

        \node[caja] (frontend) {Frontend SPA\\Vue 3 + Vite + Pinia};
        \node[caja, below=of frontend] (api) {API REST Quarkus\\(Capa de Aplicación)};
        \node[caja, below=of api] (dominio) {Dominio \\ Arquitectura Hexagonal};
        \node[caja, below=of dominio] (persistence) {Persistencia\\JPA + SQLite / PostgreSQL};

        \node[caja, right=4.8cm of api] (auth) {Identidad y Acceso\\Keycloak + JWT};
        \node[caja, right=4.8cm of dominio] (observability) {Observabilidad\\Prometheus + Grafana + Cloud Monitoring};
        \node[caja, right=4.8cm of persistence] (storage) {Respaldo y Archiving\\Cloud Storage + IAM};

        \node[externo, left=4.8cm of api] (aseguradoras) {APIs de aseguradoras\\(REST/SOAP)};
        \node[externo, left=4.8cm of dominio] (farmacias) {Farmacias y proveedores externos};

        \draw[->, thick] (frontend) -- node[right]{HTTPS / REST} (api);
        \draw[->, thick] (api) -- node[right]{DTOs} (dominio);
        \draw[->, thick] (dominio) -- node[right]{Repositorios} (persistence);
        \draw[<->, thick] (api) -- node[above]{OIDC} (auth);
        \draw[->, thick] (dominio.east) -- node[above]{Métricas de dominio} (observability.west);
        \draw[->, thick] (persistence.east) -- node[above]{Backups programados} (storage.west);
        \draw[->, thick, dashed] (api.west) -- node[above]{Adaptadores REST} (aseguradoras.east);
        \draw[->, thick, dashed] (dominio.west) -- node[above]{Anticorrupción} (farmacias.east);
        \draw[->, thick, dashed] (observability) |- (frontend);
    \end{tikzpicture}
    \caption{Arquitectura lógica actualizada considerando observabilidad e identidad federada.}
    \label{fig:diag-general-fase3}
\end{figure}

\subsection{Pipeline CI/CD consolidado en Google Cloud}

El pipeline de integración y despliegue continuo se reubicó en Google Cloud Build para aprovechar artefactos administrados, servicio sin servidor (Cloud Run) y reducción de mantenimiento de infraestructura. Se intentó replicar la automatización en AWS CodePipeline y Azure DevOps; sin embargo, la necesidad de duplicar secretos, runners y repositorios de artefactos incrementó los costos operativos, por lo que la ejecución quedó centralizada en Google Cloud para esta fase. Las plantillas Terraform y YAML quedaron preparadas para habilitar los proveedores adicionales en una iteración futura.

\subsubsection{Flujo principal del pipeline}

\begin{enumerate}[leftmargin=1.2cm]
    \item \textbf{Detonador}: Commits o pull requests en Git generan un trigger en Cloud Build.
    \item \textbf{Pre-checks}: Se validan convenciones de ramas, dependencias y versiones con `npm audit`, `npm outdated` y `mvn -pl backend dependency:analyze`.
    \item \textbf{Integración continua}: Ejecución paralela de pruebas (`npm run test:unit`, `npm run lint`, Playwright en modo headless y `./mvnw verify`).
    \item \textbf{Calidad}: Análisis en SonarCloud con Quality Gate obligatorio, métricas de cobertura y deuda técnica.
    \item \textbf{Construcción}: Build de imágenes Docker para frontend y backend; publicación en Artifact Registry con etiquetas semánticas y digest SHA.
    \item \textbf{Seguridad}: Escaneo con Trivy y revisión de dependencias con Snyk (pipeline nocturno).
    \item \textbf{Despliegue}: Promociones automáticas a ambientes `dev` y `qa` (Cloud Run + Cloud SQL); aprobación manual para `prod`.
    \item \textbf{Observabilidad}: Ejecución de pruebas sintéticas, recolección de métricas (Prometheus/Grafana) y publicación en Cloud Monitoring.
\end{enumerate}

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[font=\small, node distance=1.7cm]
        \tikzstyle{stage}=[rectangle, draw=azulBrand, thick, rounded corners=2pt, fill=white, minimum width=3.6cm, minimum height=1.1cm, align=center]
        \tikzstyle{decision}=[diamond, draw=naranjaAlerta, thick, fill=white, aspect=2, inner sep=2pt, align=center]

        \node[stage] (git) {Commit / PR\\Git Repository};
        \node[stage, right=of git] (ci) {CI Parallel\\Tests + Lint};
        \node[stage, right=of ci] (sonar) {SonarCloud\\Quality Gate};
        \node[stage, right=of sonar] (build) {Build Imágenes\\Artifact Registry};
        \node[stage, right=of build] (scan) {Trivy / Snyk\\Vulnerabilities};
        \node[decision, right=of scan] (gate) {\small ¿Severidad crítica?};
        \node[stage, above=1.5cm of gate] (fix) {Corrección\\Automática / Manual};
        \node[stage, below right=1.3cm and 1.1cm of gate] (deploy) {Deploy\\Cloud Run + Cloud SQL};
        \node[stage, right=of deploy] (monitor) {Smoke Tests\\Observabilidad};

        \draw[->, thick] (git) -- (ci);
        \draw[->, thick] (ci) -- (sonar);
        \draw[->, thick] (sonar) -- (build);
        \draw[->, thick] (build) -- (scan);
        \draw[->, thick] (scan) -- (gate);
        \draw[->, thick] (gate) -- node[above]{Sí} (fix);
        \draw[->, thick] (fix.south) |- (ci);
        \draw[->, thick] (gate) -- node[below]{No} (deploy);
        \draw[->, thick] (deploy) -- (monitor);
    \end{tikzpicture}
    \caption{Pipeline CI/CD consolidado en Google Cloud Build.}
    \label{fig:pipeline-gcp}
\end{figure}

\subsubsection{Lecciones del pipeline anterior}

El pipeline del semestre anterior residía en Jenkins sobre infraestructura on-premise. Si bien ofrecía flexibilidad, demandaba mantenimiento continuo de agentes, almacenamiento de artefactos y gestión manual de secretos. La migración a Google Cloud permitió automatizar la rotación de credenciales, escalar bajo demanda y reducir tiempos de despliegue en 34\%.

\subsection{Análisis ADD completo de la arquitectura}

\subsubsection{Contexto y restricciones}

\begin{itemize}[leftmargin=1.2cm]
    \item \textbf{Dominio}: Gestión hospitalaria integral (pacientes, citas, inventario, facturación y aseguradoras).
    \item \textbf{Usuarios}: Administradores, médicos, enfermería, personal de farmacia, pacientes y operadores de aseguradoras.
    \item \textbf{Tecnología}: Frontend SPA (Vue 3), backend Quarkus con arquitectura hexagonal, base SQLite (dev/QA) y plan de migración a PostgreSQL administrado (Cloud SQL / RDS / Azure Database).
    \item \textbf{Restricciones}: Cumplimiento de LOPDP, interoperabilidad con APIs legacy (SOAP), despliegue contenedorizado y monitoreo unificado.
    \item \textbf{Drivers}: Tiempos de respuesta <850~ms con 5\,000 usuarios concurrentes, disponibilidad 99.5\%, auditoría completa y crecimiento de catálogo médico.
\end{itemize}

\subsubsection{Escenarios de calidad priorizados}

\begin{longtable}{p{0.9cm} p{2.2cm} p{4.2cm} p{4.8cm} p{3.2cm}}
    \caption{Escenarios de atributos de calidad Fase~III.}\label{tab:escenarios-fase3}\\
    \toprule
    ID & Atributo & Estímulo & Respuesta esperada & Métrica / Umbral \\
    \midrule
    \endfirsthead
    \toprule
    ID & Atributo & Estímulo & Respuesta esperada & Métrica / Umbral \\
    \midrule
    \endhead
    Q1 & Disponibilidad & Falla de instancia en horario pico & Cloud Run redirige tráfico a instancia sana y reinicia en caliente & Recuperación < 60~s \\
    Q2 & Desempeño & 5\,000 usuarios crean citas simultáneamente & Autoescalado y caché de catálogos & P\textsubscript{95} < 850~ms \\
    Q3 & Seguridad & Token expirado usado en endpoint crítico & Rechazo inmediato, registro y alerta & 100\% solicitudes inválidas bloqueadas \\
    Q4 & Escalabilidad & Alta de nueva clínica en 2 semanas & Provisionamiento automatizado de tenant y datos maestros & Tiempo total < 5 días \\
    Q5 & Observabilidad & Latencia promedio se incrementa 20\% & Alertas y dashboards muestran causa raíz & Alerta < 2 min \\
    Q6 & Mantenibilidad & Nueva regla de priorización de citas & Implementación con pruebas y despliegue continuo & Entrega < 2 días, cobertura >90\% \\
    Q7 & Compatibilidad & Integración con API SOAP legacy & Adaptador anticorrupción traduce a REST & Respuesta < 1.5 s \\
    Q8 & Portabilidad & Migración a PostgreSQL administrado & Migraciones versionadas con rollback & Downtime < 30 min, 0 pérdida de datos \\
    Q9 & UX & Usuario móvil carga dashboard & PWA + CDN entrega contenido optimizado & LCP < 2.5 s \\
    \bottomrule
\end{longtable}

\subsubsection{Iteraciones ADD}

\begin{longtable}{p{0.8cm} p{4.5cm} p{5.2cm} p{5.2cm}}
    \caption{Iteraciones del proceso ADD (nueve iteraciones).}\label{tab:add-iteraciones-fase3}\\
    \toprule
    Iter. & Decisión principal & Tácticas aplicadas & Artefactos / Evidencias \\
    \midrule
    \endfirsthead
    \toprule
    Iter. & Decisión principal & Tácticas aplicadas & Artefactos / Evidencias \\
    \midrule
    \endhead
    1 & Elegir arquitectura hexagonal & Separación de puertos/adaptadores, inyección de dependencias & Diagramas de capas, interfaces de repositorio, pruebas unitarias aisladas \\
    2 & Despliegue en contenedores serverless & Health checks, escalado horizontal & Dockerfiles optimizados, configuración Cloud Run, límites de concurrencia \\
    3 & Autenticación centralizada & OIDC/JWT, expiración corta, refresco de tokens & Configuración Keycloak, políticas de scopes, middleware en frontend \\
    4 & Optimización de catálogos & Caché near-cache en frontend, TTL de catálogos, preparación de Redis & Plan de caching, configuración IndexedDB, PWA precache \\
    5 & Observabilidad proactiva & Instrumentación Micrometer, trazas distribuidas & Dashboards Grafana, reglas de alertado, exportación Cloud Monitoring \\
    6 & Multi-tenant y aislación de datos & Base por tenant, configuración dinámica, scripts semilla & Terraform + Flyway, scripts de onboarding, matriz de permisos \\
    7 & Integración con sistemas externos & Patrones de anticorrupción, colas asíncronas, resiliencia & Adaptadores REST/SOAP, manejo de reintentos, circuit breakers \\
    8 & Migración a PostgreSQL administrado & Entorno paralelo, migraciones versionadas, pruebas de humo & Scripts Flyway, plan de rollback, checklist de verificación \\
    9 & Experiencia PX y accesibilidad & Bundle splitting, lazy loading, métricas Lighthouse & Estrategia PWA, auditorías periódicas, backlog de UX mobile-first \\
    \bottomrule
\end{longtable}

\subsection{Matrices de deuda técnica actualizadas}

Se actualizaron las matrices de deuda técnica diferenciando pipeline CI/CD y aplicación, con foco en remediaciones inmediatas.

\subsubsection{Pipeline CI/CD}

\begin{longtable}{p{0.9cm} p{3.4cm} p{4.8cm} p{2.6cm} p{2.6cm} p{4.5cm}}
    \caption{Matriz de deuda técnica -- Pipeline CI/CD.}\label{tab:deuda-pipeline-fase3}\\
    \toprule
    ID & Elemento & Evidencia & Severidad & Esfuerzo & Plan de remediación \\
    \midrule
    \endfirsthead
    \toprule
    ID & Elemento & Evidencia & Severidad & Esfuerzo & Plan de remediación \\
    \midrule
    \endhead
    DP1 & Multi-cloud automation & Plantillas AWS/Azure desactualizadas y sin runners & Alta & 24 h DevOps & Actualizar Terraform, parametrizar secretos y habilitar pipelines espejo en modo \emph{dry-run} \\
    DP2 & Datos de pruebas E2E & Playwright falla por data volátil & Media & 12 h QA & Sembrar fixtures determinísticos, aislar datos por entorno y limpiar tras cada run \\
    DP3 & Pruebas de seguridad dinámicas & OWASP ZAP manual, Snyk sólo nocturno & Alta & 16 h SecDevOps & Integrar ZAP automatizado por rama y forzar build break por CVSS \(>7) \\
    DP4 & Observabilidad del pipeline & Métricas básicas en Cloud Build & Media & 8 h & Exportar logs a BigQuery y dashboards en Grafana con SLIs de duración y tasa de fallo \\
    DP5 & Retención de artefactos & Imágenes Docker sin política de expiración & Baja & 6 h & Configurar expiración automática y retención por etiquetas \texttt{release/\*} \\
    \bottomrule
\end{longtable}

\subsubsection{Aplicación}

\begin{longtable}{p{0.9cm} p{3.5cm} p{4.8cm} p{2.6cm} p{2.6cm} p{4.4cm}}
    \caption{Matriz de deuda técnica -- Aplicación (Fase~III).}\label{tab:deuda-app-fase3}\\
    \toprule
    ID & Módulo & Evidencia & Impacto & Prioridad & Acción recomendada \\
    \midrule
    \endfirsthead
    \toprule
    ID & Módulo & Evidencia & Impacto & Prioridad & Acción recomendada \\
    \midrule
    \endhead
    DA1 & Gestión de pacientes & Lógica compleja en componentes Vue, pruebas unitarias limitadas & Alta & P1 & Refactor a composables, ampliar pruebas y habilitar `data-test-id` para E2E \\
    DA2 & Inventario farmacéutico & Consultas sin índices compuestos en SQLite & Alta & P1 & Crear índices y preparar migración a PostgreSQL con `EXPLAIN ANALYZE` \\
    DA3 & Seguridad & TTL de tokens prolongado en frontend y sesiones persistentes & Media & P1 & Reducir expiración, refresco "silent renew" y revocación por lista negra \\
    DA4 & Reportes masivos & Generación sin colas asíncronas, bloquea threads & Media & P2 & Incorporar Pub/Sub y jobs asíncronos con notificaciones en tiempo real \\
    DA5 & Observabilidad funcional & Métricas limitadas a HTTP 2xx/5xx & Baja & P2 & Añadir métricas de dominio (citas pendientes, stock crítico) y traces \\
    DA6 & Internacionalización & Textos fijos en español & Baja & P3 & Integrar librería i18n y centralizar recursos \\
    \bottomrule
\end{longtable}

\subsection{Análisis de performance y causa raíz}

\subsubsection{Backend (pruebas de carga k6)}

Se ejecutó un plan de estrés con 5\,000 usuarios concurrentes durante 15 minutos. Los resultados se resumen en la Tabla~\ref{tab:backend-performance}.

\begin{table}[htbp]
    \centering
    \caption{Resultados de performance del backend (k6).}\label{tab:backend-performance}
    \begin{tabular}{lccc}
        \toprule
        Métrica & Objetivo & Observado & Estado \\
        \midrule
        Throughput promedio & $\geq$ 280 req/s & 265 req/s & \textcolor{naranjaAlerta}{Ligeramente bajo} \\
        Latencia P\textsubscript{95} & $\leq$ 850 ms & 910 ms & \textcolor{red}{Incumplido} \\
        Tasa de errores HTTP & $\leq$ 1\% & 0.8\% & \textcolor{verdeOk}{Cumplido} \\
        Uso CPU (Cloud Run) & $\leq$ 70\% & 78\% & \textcolor{naranjaAlerta}{Alto} \\
        Tiempo de GC & $\leq$ 10\% & 8\% & \textcolor{verdeOk}{Cumplido} \\
        \bottomrule
    \end{tabular}
\end{table}

\textbf{Causa raíz}: La degradación se concentra en las consultas de inventario con filtros múltiples sobre SQLite, ausencia de índices compuestos y falta de caché. El autoscalado de Cloud Run tarda ~6~s en iniciar nuevas instancias por el \emph{cold start} de Quarkus. Recomendaciones inmediatas: migrar a PostgreSQL administrado, habilitar Redis para catálogos, precalentar dos instancias mínimas y optimizar consultas con proyecciones.

\subsubsection{Frontend (auditoría Lighthouse)}

Los resultados promedio en modo móvil se presentan en la Tabla~\ref{tab:lighthouse-fase3}.

\begin{table}[htbp]
    \centering
    \caption{Resultados Lighthouse (modo móvil).}\label{tab:lighthouse-fase3}
    \begin{tabular}{lcccc}
        \toprule
        Métrica & Objetivo & Observado & Gap & Comentario \\
        \midrule
        Performance & $\geq$ 85 & 79 & -6 & Imágenes sin `srcset`, bundle inicial pesado \\
        Accesibilidad & $\geq$ 90 & 92 & +2 & Cumplido \\
        Mejores prácticas & $\geq$ 90 & 88 & -2 & Librerías sin minificar en build QA \\
        SEO & $\geq$ 90 & 95 & +5 & Cumplido \\
        LCP & $\leq$ 2.5 s & 2.9 s & +0.4 s & Falta precarga de datos y lazy loading \\
        TTI & $\leq$ 4.0 s & 3.6 s & -0.4 s & Cumplido \\
        \bottomrule
    \end{tabular}
\end{table}

\textbf{Causa raíz}: Recursos gráficos no optimizados, ausencia de `lazy loading` en tarjetas de doctores, falta de CDN global y almacenamiento de datos voluminosos en `localStorage`. Acciones: implementar `vite-image-tools`, activar `lazy loading`, usar CDN y optimizar el `service worker` para precargar rutas críticas.

\subsection{Especificaciones y costos de infraestructura recomendada}

Se compararon tres proveedores (Google Cloud, AWS, Azure) considerando ambientes dedicados (dev, QA/UAT, producción), incluyendo CPU, memoria, almacenamiento y costos anuales. Todos los montos están expresados en USD.

\subsubsection{Google Cloud Platform}

\begin{table}[htbp]
    \centering
    \caption{Sizing recomendado en Google Cloud.}\label{tab:gcp-costos}
    \begin{tabular}{lccc}
        \toprule
        Ambiente & Compute & Almacenamiento & Costo anual aproximado \\
        \midrule
        Desarrollo & Cloud Run (2 vCPU / 4 GB) + Cloud SQL db-f1-micro & 50 GB SSD & 1\,820 \\
        QA/UAT & Cloud Run (2 instancias, 2 vCPU / 4 GB) + Cloud SQL db-g1-small & 100 GB SSD & 3\,950 \\
        Producción & Cloud Run (mín. 3 instancias, 4 vCPU / 8 GB) + Cloud SQL custom-4-15360 & 500 GB SSD + Backups & 12\,480 \\
        \bottomrule
    \end{tabular}
\end{table}

\subsubsection{Amazon Web Services}

\begin{table}[htbp]
    \centering
    \caption{Sizing recomendado en AWS.}\label{tab:aws-costos}
    \begin{tabular}{lccc}
        \toprule
        Ambiente & Compute & Almacenamiento & Costo anual aproximado \\
        \midrule
        Desarrollo & ECS Fargate (1 vCPU / 2 GB) + RDS db.t4g.micro & 50 GB GP3 & 2\,150 \\
        QA/UAT & ECS Fargate (2 vCPU / 4 GB) + RDS db.t4g.small multi-AZ & 150 GB GP3 & 5\,320 \\
        Producción & ECS Fargate (3 tareas de 2 vCPU / 4 GB) + RDS db.m6g.large multi-AZ & 600 GB GP3 + Backups S3 & 14\,780 \\
        \bottomrule
    \end{tabular}
\end{table}

\subsubsection{Microsoft Azure}

\begin{table}[htbp]
    \centering
    \caption{Sizing recomendado en Azure.}\label{tab:azure-costos}
    \begin{tabular}{lccc}
        \toprule
        Ambiente & Compute & Almacenamiento & Costo anual aproximado \\
        \midrule
        Desarrollo & Azure Container Apps (2 vCPU / 4 GB) + PostgreSQL B1ms & 50 GB Premium SSD & 2\,420 \\
        QA/UAT & Azure Kubernetes Service (nodo D2s v5) + PostgreSQL B2s & 150 GB Premium SSD & 5\,680 \\
        Producción & AKS (nodos D4s v5 autoescalado) + PostgreSQL GP Standard (4 vCore / 16 GB) & 600 GB Premium SSD + Azure Backup & 15\,320 \\
        \bottomrule
    \end{tabular}
\end{table}

\noindent Pese a la evaluación de proveedores múltiples, los pipelines se ejecutan exclusivamente en Google Cloud durante esta fase debido a la complejidad de replicar secretos y runners. Se recomienda habilitar despliegues espejo cuando se estabilicen las plantillas IaC.

\subsection{Presentación ejecutiva resumida}

Se preparó un guion ejecutivo pensado para una sesión con gerentes de tecnología. Cada \emph{slide} concentra los puntos esenciales.

\begin{description}[leftmargin=1.2cm, style=nextline]
    \item[Slide 1 -- Visión general] Propósito del sistema, reducción del tiempo de registro de pacientes (45\%), confirmación de citas en menos de 2 minutos, arquitectura lógica de tres capas con observabilidad.
    \item[Slide 2 -- Logros del periodo] Cumplimiento de recomendaciones previas, migración del pipeline a Google Cloud, cobertura de pruebas (backend 78\%, frontend 82\%).
    \item[Slide 3 -- Arquitectura y calidad] Nueve escenarios de calidad priorizados, tácticas ADD implementadas, brecha principal: migración a PostgreSQL y caché distribuido.
    \item[Slide 4 -- Performance y deuda técnica] Resultados de k6 (P\textsubscript{95}=910~ms), acciones correctivas (índices, precalentar instancias, optimización frontend), top 3 deudas pipeline/aplicación.
    \item[Slide 5 -- Infraestructura y costos] Comparativo anual entre Google Cloud, AWS y Azure; decisión de consolidar pipeline en Google Cloud; próximos pasos para multicloud.
    \item[Slide 6 -- Próximas iteraciones] Migración a PostgreSQL y Redis, pruebas de seguridad automatizadas, habilitación multi-cloud, mejoras de UX móvil e internacionalización.
\end{description}

\subsection{Recomendaciones finales Fase III}

\begin{itemize}[leftmargin=1.2cm]
    \item Completar la migración a PostgreSQL administrado y habilitar Redis como caché distribuido antes de la siguiente ronda de pruebas de carga.
    \item Automatizar pruebas de seguridad (OWASP ZAP, Snyk) dentro del pipeline principal con umbrales de bloqueo.
    \item Implementar despliegues espejo en AWS CodePipeline y Azure DevOps una vez estabilizadas las plantillas Terraform.
    \item Aumentar la cobertura de pruebas E2E en flujos de pacientes y reportes, utilizando datos determinísticos.
    \item Mejorar la experiencia móvil mediante optimización de imágenes, `lazy loading` y auditorías Lighthouse trimestrales.
    \item Formalizar un plan de observabilidad de negocio (métricas de citas, stock crítico, notificaciones fallidas) para la toma de decisiones operativas.
\end{itemize}

\newpage
\section{Conclusión}

El \textbf{PROYECTO2025-HOSPITAL2-SOFI} representa una solución integral de gestión hospitalaria que combina tecnologías modernas con mejores prácticas de desarrollo. El sistema ha sido diseñado con una arquitectura escalable, mantenible y segura que cumple con los requisitos de un entorno hospitalario real.

\subsection{Logros Principales}

\begin{enumerate}
    \item \textbf{Arquitectura Robusta}: Implementación de patrones arquitectónicos probados
    \item \textbf{Seguridad Integral}: Sistema de autenticación y autorización completo
    \item \textbf{Escalabilidad}: Diseño que permite crecimiento futuro
    \item \textbf{Calidad de Código}: Implementación de testing y análisis de calidad
    \item \textbf{CI/CD Automatizado}: Pipeline en Google Cloud Build con análisis de calidad y despliegue continuo multi-entorno
    \item \textbf{Multi-entorno}: Soporte para desarrollo, UAT y producción
\end{enumerate}

\subsection{Tecnologías Implementadas}

\begin{itemize}
    \item \textbf{Backend}: Quarkus 3.8.6, Java 17, Hibernate ORM, SQLite
    \item \textbf{Frontend}: Vue.js 3.5.13, TypeScript, Tailwind CSS, Pinia
    \item \textbf{DevOps}: Google Cloud Build, Cloud Run, Artifact Registry, SonarCloud, Trivy (con Jenkins como referencia histórica)
    \item \textbf{Testing}: JUnit 5, Vitest, Playwright
    \item \textbf{Documentación}: Markdown, TikZ diagrams
\end{itemize}

\subsection{Beneficios del Sistema}

\begin{enumerate}
    \item \textbf{Eficiencia Operativa}: Automatización de procesos hospitalarios
    \item \textbf{Mejor Experiencia de Usuario}: Interfaces intuitivas y responsivas
    \item \textbf{Gestión Centralizada}: Administración unificada de todos los recursos
    \item \textbf{Trazabilidad}: Registro completo de actividades y cambios
    \item \textbf{Flexibilidad}: Sistema adaptable a diferentes necesidades hospitalarias
\end{enumerate}

\subsection{Próximos Pasos}

\begin{enumerate}
    \item \textbf{Migración a PostgreSQL + Redis}: Ejecutar la migración administrada y habilitar caché distribuido para reducir latencias.
    \item \textbf{Pruebas de seguridad automáticas}: Integrar OWASP ZAP y Snyk al pipeline principal con umbrales de bloqueo.
    \item \textbf{Estrategia multi-cloud}: Activar pipelines espejo en AWS y Azure una vez estabilizadas las plantillas IaC.
    \item \textbf{Optimización UX móvil e internacionalización}: Mejorar rendimiento móvil, incorporar i18n y consolidar auditorías Lighthouse.
    \item \textbf{Observabilidad de negocio}: Expandir dashboards operativos y métricas accionables para áreas clínicas y administrativas.
\end{enumerate}

El proyecto demuestra la capacidad de desarrollar sistemas complejos utilizando tecnologías modernas y metodologías ágiles, estableciendo una base sólida para el crecimiento futuro del sistema de gestión hospitalaria.

\subsection{Resumen de Iteraciones}

\subsubsection{Pipeline CI/CD - Resumen}
\begin{enumerate}
    \item \textbf{Iteración 1}: Configuración base del pipeline
    \item \textbf{Iteración 2}: Integración de build y testing
    \item \textbf{Iteración 3}: Análisis de calidad con SonarQube
    \item \textbf{Iteración 4}: Contenedorización y Docker
    \item \textbf{Iteración 5}: Despliegue multi-entorno
    \item \textbf{Iteración 6}: Monitoreo y notificaciones
\end{enumerate}

\subsubsection{Aplicación - Resumen}
\begin{enumerate}
    \item \textbf{Iteración 1}: Fundación del sistema
    \item \textbf{Iteración 2}: Sistema de roles y autorización
    \item \textbf{Iteración 3}: Gestión médica core
    \item \textbf{Iteración 4}: Servicios médicos y reportes
    \item \textbf{Iteración 5}: Optimización y performance
    \item \textbf{Iteración 6}: Monitoreo y observabilidad
\end{enumerate}

\subsection{Métricas de Éxito}
\begin{itemize}
    \item \textbf{Cobertura de Tests}: >80\%
    \item \textbf{Tiempo de Build}: <5 minutos
    \item \textbf{Tiempo de Despliegue}: <2 minutos
    \item \textbf{Tiempo de Respuesta}: <200ms
    \item \textbf{Uptime}: >99.9\%
    \item \textbf{Calidad de Código}: Rating A en SonarQube
\end{itemize}

---

\textbf{Documento generado automáticamente} \\
\textbf{Fecha}: \today \\
\textbf{Versión}: 1.1.0 \\
\textbf{Proyecto}: PROYECTO2025-HOSPITAL2-SOFI

\end{document}

